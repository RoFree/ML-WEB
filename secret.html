<html><!--  manifest="sinkhole.manifest" --><head>
<meta charset="utf-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" href="images/icon-144.png" size="144x144">
<meta name="viewport" id="viewport" content="initial-scale=0.5;user-scalable=no">
<title>Sinkhole (Post-Dare)</title>
<script src="/mint/?js"></script><script type="text/javascript" src="http://shauninman.com/mint/?record&amp;key=39446641343075505465313337727a7544514c704c3635626474517a35316c&amp;referer=&amp;resource=http%3A//shauninman.com/ludumdare/alone/sinkhole/&amp;resource_title=Sinkhole%20%28Post-Dare%29&amp;resource_title_encoded=0&amp;window_width=2048&amp;window_height=969&amp;resolution=2048x1152&amp;flash_version=0&amp;1556731049063&amp;serve_js"></script>
<style>
body
{
	position: relative;
	background: #000; /* #1e262f */
	color: #ccc;
	font: 12px/18px sans-serif;
	margin: 0;
	text-align: center;
}
canvas
{
	position: relative;
	background: #000;
	/* required for zoom() crispness but not for scale() */
	image-rendering: -webkit-optimize-contrast;
	image-rendering: -moz-crisp-edges;
	image-rendering: -o-crisp-edges;
	-ms-interpolation-mode: nearest-neighbor;
}
div
{
	text-align: left;
	margin: 0 auto;
}

label
{
	opacity: 0.2;
}
label:hover
{
	opacity:1;
}

</style>
</head>
<body>
<div id="game" style="width: 1440px; height: 960px;"><canvas id="game-canvas" width="1440" height="960" style="transform: scale(1, 1); transform-origin: 0px 0px; zoom: 1;"></canvas></div>
<pre id="debug"></pre>
<!-- http://devpro.it/javascript_id_137.html -->
<!-- <script src="AStar_memtronic.js"></script> -->
<script src="AStar.js"></script>
<script>

// IMPORTS ------------------------------------------------------------

// http://ejohn.org/blog/simple-javascript-inheritance/
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;
  // The base Class implementation (does nothing)
  this.Class = function(){};
  
  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;
    
    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;
    
    // Copy the properties over onto the new prototype
    for (var name in prop) {
      // Check if we're overwriting an existing function
      prototype[name] = typeof prop[name] == "function" && 
        typeof _super[name] == "function" && fnTest.test(prop[name]) ?
        (function(name, fn){
          return function() {
            var tmp = this._super;
            
            // Add a new ._super() method that is the same method
            // but on the super-class
            this._super = _super[name];
            
            // The method only need to be bound temporarily, so we
            // remove it when we're done executing
            var ret = fn.apply(this, arguments);        
            this._super = tmp;
            
            return ret;
          };
        })(name, prop[name]) :
        prop[name];
    }
    
    // The dummy class constructor
    function Class() {
      // All construction is actually done in the init method
      if ( !initializing && this.init )
        this.init.apply(this, arguments);
    }
    
    // Populate our constructed prototype object
    Class.prototype = prototype;
    
    // Enforce the constructor to be what we expect
    Class.prototype.constructor = Class;

    // And make this class extendable
    Class.extend = arguments.callee;
    
    return Class;
  };
})();

// http://ejohn.org/projects/flexible-javascript-events/
function addEvent( obj, type, fn ) {
  if ( obj.attachEvent ) {
    obj['e'+type+fn] = fn;
    obj[type+fn] = function(){obj['e'+type+fn]( window.event );}
    obj.attachEvent( 'on'+type, obj[type+fn] );
  } else
    obj.addEventListener( type, fn, false );
};
function removeEvent( obj, type, fn ) {
  if ( obj.detachEvent ) {
    obj.detachEvent( 'on'+type, obj[type+fn] );
    obj[type+fn] = null;
  } else
    obj.removeEventListener( type, fn, false );
};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
window.requestAnimFrame = (function() {
	// we don't really need all the extra frames
	return function(callback, element) { window.setTimeout(callback, 1000 / 30); };
	
	return  window.requestAnimationFrame	|| 
	window.webkitRequestAnimationFrame		|| 
	window.mozRequestAnimationFrame			|| 
	window.oRequestAnimationFrame			|| 
	window.msRequestAnimationFrame			|| 
	function(/* function */ callback, /* DOMElement */ element)
	{
		window.setTimeout(callback, 1000 / 60);
	};
})();

// http://mir.aculo.us/2010/06/04/making-an-ipad-html5-app-making-it-really-fast/
var supportsTouch = 'createTouch' in document;


// FRAMEWORK BEGINS ---------------------------------------------------

// Types //////////////////////////////////////////////////////////////
var YES 	= true;
var NO		= false;
var Size 	= function(w,h) { return {'width':w, 'height':h}; };
var Point 	= function(x,y) { return {'x':x, 'y':y}; };
var Rect	= function(x,y,w,h) { return {'origin':Point(x,y), 'size':Size(w,h)}; };

// Util ///////////////////////////////////////////////////////////////
function $(id) { return document.getElementById(id); };
function clone(o) { return JSON.parse(JSON.stringify(o)); };
function isEqual(o1,o2) { return JSON.stringify(o1)==JSON.stringify(o2); };

// Sort ///////////////////////////////////////////////////////////////
function compareZIndex(a, b) {
	return a.zIndex - b.zIndex;
};

function compareY(a, b) {
	return a.body.origin.y - b.body.origin.y;
};

// Geometry ///////////////////////////////////////////////////////////
function rectContainsPoint(r, p)
{
	var h = (p.x >= r.origin.x && p.x < r.origin.x + r.size.width);
	var v = (p.y >= r.origin.y && p.y < r.origin.y + r.size.height);
	return (h && v);
};

function rectIsEmpty(r)
{
	return (r.size.width && r.size.height) ? NO : YES;
};

// based on http://stackoverflow.com/questions/2752349/fast-rectangle-to-rectangle-intersection
function rectIntersectsRect(r1, r2)
{
	if (!r1 || !r2) return false;
	
	return !(r2.origin.x > r1.origin.x+r1.size.width 	||	// r2 is right of r1
		r2.origin.x+r2.size.width < r1.origin.x 		||	// r2 is left of r1
		r2.origin.y > r1.origin.y+r1.size.height 		||	// r2 is below r1
		r2.origin.y+r2.size.height < r1.origin.y);			// r2 is above r1
};

function intersectingRect(r1, r2)
{
	var r = Rect(0,0,0,0);
	if (rectIntersectsRect(r1,r2))
	{
		var x1 = r1.origin.x;
		var x2 = r2.origin.x;
		var xw1 = r1.origin.x + r1.size.width;
		var xw2 = r2.origin.x + r2.size.width;
		
		var y1 = r1.origin.y;
		var y2 = r2.origin.y;
		var yh1 = r1.origin.y + r1.size.height;
		var yh2 = r2.origin.y + r2.size.height;
		
		var l = x1 > x2 ? x1 : x2;
		var r = xw1 < xw2 ? xw1 : xw2;
		var t = y1 > y2 ? y1 : y2;
		var b = yh1 < yh2 ? yh1 : yh2;
		
		r = Rect(l,t, r-l, b-t);
	};
	return r;
};

// Base Classes ///////////////////////////////////////////////////////
var Textures = // Singleton
{
	srcCanvas : null,
	dstCanvas : null,
	srcCtx 	: null,
	dstCtx 	: null,
	
	waiting	: {}, // src:[texture]
	cache 	: {}, // src:img
	scaled	: {}, // scale:{src:img}
	initialize : function()
	{
		this.srcCanvas = document.createElement('canvas');
		this.dstCanvas = document.createElement('canvas');
		this.srcCtx = this.srcCanvas.getContext('2d');
		this.dstCtx = this.dstCanvas.getContext('2d');
		this.scaled[1] = {};
	},
	preload : function(srcs)
	{
		for (var i=0; i<srcs.length; i++)
		{
			new Texture(srcs[i]);
		};
	},
	isReady : function(texture)
	{
		// not scaled yet
		if (!this.scaled[System._scale] || !this.scaled[System._scale][texture.src])
		{
			if (this.cache[texture.src] && this.cache[texture.src].isReady) // ready to be scaled
			{
				this.scale(texture.src);
			};
			return false;
		}
		else
		{
			return this.scaled[System._scale][texture.src].isReady;
		};
	},
	img : function(texture)
	{
		return this.scaled[System._scale][texture.src];
	},
	load : function(texture)
	{
		if (this.cache[texture.src]) // already cached
		{
			if (this.cache[texture.src].isReady) // already ready
			{
				texture.onload(this.cache[texture.src]);
			}
			else // not ready yet
			{
				this.waiting[texture.src].push(texture);
			};
			return;
		};
		
		// prepare the wait list if necessary
		if (!this.waiting[texture.src]) this.waiting[texture.src] = [];
		
		var img = new Image();
		img.isReady = NO;
		img.onload = function()
		{
			img.isReady = YES;
			for (var i=0;i<Textures.waiting[texture.src].length; i++)
			{
				Textures.waiting[texture.src][i].onload(this);
			};
			Textures.waiting[texture.src] = [];
			Textures.scale(texture.src);
		};
		this.cache[texture.src] = img;
		this.scaled[1][texture.src] = img;
		this.waiting[texture.src].push(texture);
		img.src = texture.src;
	},
	scale : function(src)
	{
		var scale = System._scale;
		
		if (!this.scaled[scale]) this.scaled[scale] = {};
		if (this.scaled[scale][src]) return; // already scaled
		
		var img = this.cache[src];
		var dstImg = new Image();
		dstImg.isReady = NO;
		dstImg.onload = function() { this.isReady = YES; };
		this.scaled[scale][src] = dstImg; // add as soon as possible to prevent duplicate scaling
		
		// set up source
		this.srcCanvas.width = img.width;
		this.srcCanvas.height = img.height;
		this.srcCtx.clearRect(0,0,img.width,img.height);
		this.srcCtx.drawImage(img,0,0);
		var srcData = this.srcCtx.getImageData(0,0,img.width,img.height).data;

		var sw = scale * img.width;
		var sh = scale * img.height;

		// set up destination
		this.dstCanvas.width = sw;
		this.dstCanvas.height = sh;
		this.dstCtx.clearRect(0,0,sw,sh);
		var dstImgData = this.dstCtx.getImageData(0,0,sw,sh);
		var dstData = dstImgData.data;

		// scale
		var srcP = 0;
	    var dstP = 0;
	    for (var y = 0; y < img.height; ++y) {
	        for (var i = 0; i < scale; ++i) {
	            for (var x = 0; x < img.width; ++x) {
	                var srcP = 4 * (y * img.width + x);
	                for (var j = 0; j < scale; ++j) {
	                    var tmp = srcP;
	                    dstData[dstP++] = srcData[tmp++];
	                    dstData[dstP++] = srcData[tmp++];
	                    dstData[dstP++] = srcData[tmp++];
	                    dstData[dstP++] = srcData[tmp++];
	                };
	            };
	        };
	    };
		this.dstCtx.putImageData(dstImgData,0,0);
		dstImg.src = this.dstCanvas.toDataURL();
	}
};
Textures.initialize();

var Texture = Class.extend(
{
	init : function(src,w,h) // w,h are tileSize not imgSize
	{
		this.isReady 	= NO;
		this.src 		= src;
		this.tileSize	= Size(w,h);
		this.imgSize	= Size(0,0);
		this.sizeInTiles= Size(1,1);
		this.totalTiles	= 1;
		Textures.load(this);
	},
	onload : function(img)
	{
		this.imgSize = Size(img.width, img.height);
		if (isNaN(this.tileSize.width) || isNaN(this.tileSize.height)) this.tileSize = Size(img.width, img.height);
		var wt = img.width / this.tileSize.width;
		var ht = img.height / this.tileSize.height;
		this.sizeInTiles = Size(wt,ht);
		this.totalTiles = wt * ht;
		this.isReady = YES;
	},
	draw : function(x,y)
	{
		if (!Textures.isReady(this)) return;
		
		var s = System._scale;
		System.screen.drawImage(Textures.img(this),Math.round(x)*s,Math.round(y)*s);
	},
	drawTile : function(tile,x,y)
	{
		if (!Textures.isReady(this) || tile >= this.totalTiles) return;
		
		var s = System._scale;
		var w = this.tileSize.width;
		var h = this.tileSize.height;
		var ty = Math.floor(tile/this.sizeInTiles.width);
		var tx = tile - (ty * this.sizeInTiles.width);
		
		var sx = tx * w;
		var sy = ty * h;
		
		System.screen.drawImage(Textures.img(this),
			sx*s,sy*s,
			w*s,h*s,
			Math.round(x)*s,Math.round(y)*s,
			w*s,h*s);
	}
});

var Surface = Class.extend(
{
	init : function(x,y,w,h)
	{
		this.body 		= new Rect(x,y,w,h);
		this.crop		= null;
		this.parent 	= null;
		this.children	= [];
		this.zIndex		= 0;
		this.isVisible	= YES;
	},
	_crop : function()
	{
		if (this.crop) return this.crop;
		else if (this.parent) return this.parent._crop();
		else return Rect(0,0,this.body.size.width,this.body.size.height);
	},
	_relPos : function()
	{
		var offset = clone(this.body.origin);
		// commented out because Sinkhole was designed without relative positioning
		// if (this.parent)
		// {
		// 	var pOffset = this.parent._relPos();
		// 	offset.x += pOffset.x;
		// 	offset.y += pOffset.y;
		// };
		return offset;
	},
	center : function()
	{
		var x	= this.body.origin.x;
		var y	= this.body.origin.y;
		var hw 	= this.body.size.width/2;
		var hh	= this.body.size.height/2;
		
		switch (arguments.length)
		{
			case 0:
				return Point(x+hw,y+hh);
				break;
			case 1:
				this.body.origin = Point(arguments[0].x-hw,arguments[0].y-hh);
				break;
			default:
				this.body.origin = Point(arguments[0]-hw,arguments[1]-hh);
				break;
		};
	},
	addChild : function(child) 
	{
		child.parent = this;
		this.children.push(child);
		this.children.sort(compareZIndex);
	},
	removeChild : function(child)
	{
		for (var i in this.children)
		{
			if (this.children[i] == child)
			{
				System.input.unregisterTarget(child);
				child.parent = null;
				this.children.splice(i,1);
				break;
			};
		};
	},
	removeAllChildren : function()
	{
		for (var i in this.children)
		{
			var child = this.children[i];
			System.input.unregisterTarget(child);
			child.parent = null;
		};
		this.children = [];
	},
	update : function(elapsed) 
	{
		for (var i in this.children)
		{
			this.children[i].update(elapsed);
		};
	},
	render : function() 
	{
		for (var i in this.children)
		{
			if (this.children[i].isVisible)
			{
				this.children[i].render();
			};
		};
	}
});

// sorts by body.origin.y instead of zIndex - PERSPECTIVE!
var SurfaceY = Surface.extend(
{
	addChild : function(child) 
	{
		child.parent = this;
		this.children.push(child);
		this.children.sort(compareY);
	}
});

// Surfaces ///////////////////////////////////////////////////////////
var State = Surface.extend(
{
	init : function()
	{
		this._super(0,0,System.body.size.width,System.body.size.height);
	}
});

var Rectangle = Surface.extend(
{
	init : function(x,y,w,h,color)
	{
		this._super(x,y,w,h);
		this.color = color;
	},
	render : function()
	{
		var s = System._scale;
		var crop = this._crop();
		var offset = this._relPos();
		System.screen.fillStyle = this.color;
		System.screen.fillRect(Math.round(offset.x-crop.origin.x)*s, 
								Math.round(offset.y-crop.origin.y)*s, 
								this.body.size.width*s, this.body.size.height*s);
	}
});

var Tile = Surface.extend(
{
	init : function(x,y,w,h,src)
	{
		this._super(x,y,w,h);
		this.texture 		= new Texture(src,w,h);
		this.currentTile 	= 0;
	},
	render : function()
	{
		var crop = this._crop();
		var offset = this._relPos();
		this.texture.drawTile(this.currentTile, 
			offset.x-crop.origin.x, 
			offset.y-crop.origin.y);
	}
});

var Wallpaper = Surface.extend(
{
	init : function(x,y,w,h,src)
	{
		this._super(x,y,w,h);
		this.texture = new Texture(src);
	},
	render : function()
	{
		var x = 0;
		var y = 0;
		var crop = this._crop();
		var offset = this._relPos();
		
		while (x < this.body.size.width)
		{
			y = 0;
			while (y < this.body.size.height)
			{
				var nx = x + offset.x - crop.origin.x;
				var ny = y + offset.y - crop.origin.y;
				
				if (nx+this.texture.tileSize.width  >= this.body.origin.x && 
					ny+this.texture.tileSize.height >= this.body.origin.y &&
					nx <= -crop.origin.x + crop.size.width &&
					ny <= -crop.origin.y + crop.size.height)
				{
					this.texture.draw(nx,ny);
				};
				
				y += this.texture.tileSize.height;
			};
			x += this.texture.tileSize.width;
		};
	}
});

var TileMap = Surface.extend(
{
	init : function(x,y,w,h,src,tiles) // w/h refer to tileSize, not mapSize
	{
		//x,y must be 0,0 or behavior is hinky
		this._super(x,y,w*tiles[0].length,h*tiles.length);
		this.texture = new Texture(src,w,h);
		this.tiles = tiles;
		this.offset = 0;
	},
	render : function()
	{
		var x = 0;
		var y = 0;
		var crop = this._crop();
		var offset = this._relPos();
		
		// will only ever draw 176 tiles max (perfect is 15x10, bleed is 16x11)
		while (x < this.tiles[0].length)
		{
			y = 0;
			while (y < this.tiles.length)
			{
				var tile = this.tiles[y][x];
				var nx = offset.x + x*this.texture.tileSize.width;
				var ny = offset.y + y*this.texture.tileSize.height;
				if (nx+this.texture.tileSize.width  >= crop.origin.x && 
					ny+this.texture.tileSize.height >= crop.origin.y &&
					nx < crop.origin.x + crop.size.width &&
					ny < crop.origin.y + crop.size.height
					)
				{
					this.texture.drawTile(tile+this.offset,
						nx-crop.origin.x,
						ny-crop.origin.y);
				};
				y++;
			};
			x++;
		};
	}
});

var Sprite = Tile.extend(
{
	init : function(x,y,w,h,src)
	{
		this._super(x,y,w,h,src);
		
		this.sequences = {};
		this.frameDuration = 0.2;
		this.frameOffset = 0;
		this.sequenceElapsed = 0;
		this.currentSequence = null;
		this.lastSequence = null;
		this.currentFrame = 0;
		this.shouldPlayOnce = NO;
	},
	update : function(elapsed)
	{
		if (!this.isVisible) return;
		
		if (this.currentSequence != this.lastSequence)
		{
			this.currentFrame = 0;
			this.sequenceElapsed = 0;
		};
		
		this.sequenceElapsed += elapsed;

		if (this.sequenceElapsed > this.frameDuration)
		{
			this.sequenceElapsed = 0;
			this.currentFrame++;
			if (this.currentFrame >= this.sequences[this.currentSequence].length)
			{
				if (this.shouldPlayOnce) this.currentFrame--; // undo, stay on last frame
				else this.currentFrame = 0;
			};
		};
		this.currentTile = this.sequences[this.currentSequence][this.currentFrame] + this.frameOffset;
		this.lastSequence = this.currentSequence;
	}
});

var Mask = Surface.extend(
{
	init : function()
	{
		this._super();
		this.body = System.body;
		this.s = System._scale;
		this.buffer = document.createElement('canvas');
		this.buffer.width 	= this.s * this.body.size.width;
		this.buffer.height 	= this.s * this.body.size.height;
	},
	render : function()
	{
		if (this.s != System._scale)
		{
			this.s = System._scale;
			this.buffer.width 	= this.s * this.body.size.width;
			this.buffer.height 	= this.s * this.body.size.height;
		};
		
		// return this._super(); // masks are not the reason for slow performance on iPod touch
		
		System.screen = this.buffer.getContext('2d'); // swap to buffer so children can draw to mask
		System.screen.clearRect(0,0,this.buffer.width,this.buffer.height);
		this._super(); // render children
		System.screen = System.canvas.getContext('2d'); // swap back to actual screen to resume normal drawing
		
		// apply mask
		System.screen.save();
		System.screen.globalCompositeOperation = 'destination-in'; // retina iPad doesn't have enough memory to composite
		System.screen.drawImage(this.buffer,0,0);
		System.screen.restore();
	}
});

// conflates the separate Font and TextMap classes of SI2d proper
// (distinction is unnecessary here) and lacks a few of features
var TextMap = Surface.extend(
{
	init : function()
	{
		this._super(0,0,0,0);
		this.texture = null;
		this.chars = {};
		this.charWidth = 0;
		this.charWidths = {};
		this.offsetChar = '*';
		this.offsetTile = 0;
		this.offsetSize = 0;
		
		this.maxWidth = 0;

		this.text = '';
		this.cache = [];
		
		this.currentLength = -1;
		this.delay = 0;
		this.delayElapsed = 0;
		
		this.hasFinished = NO;
		this.isCentered = NO;
		this.alignment = TextMap.alignmentTypes.leftAligned;
	},
	setText : function(text)
	{
		if (this.text == text) return;
		
		this.text = text;
		var chars = text.split('');
		this.cache = [];
		var x = 0;
		var y = 0;
		var t = 0;
		var mw = 0;
		var spaces = 0;
		for (var i=0; i<chars.length; i++)
		{
			var c = chars[i];
			if (c == this.offsetChar)
			{
				this.offsetTile = (this.offsetTile == this.offsetSize) ? 0 : this.offsetSize;
				continue;
			};
			
			this.cache[t] = {'tile':this.chars[c], 'offset':this.offsetTile, 'origin':Point(x,y)};
			x += this.charWidths[c] ? this.charWidths[c] : this.charWidth;
			if (x > mw) mw = x;
			t++;
			
			// wrap from most recent space
			if (this.maxWidth && x > this.maxWidth)
			{
				x = 0;
				y += this.texture.tileSize.height;
				
				// find the space
				var s = this.chars[' '];
				for (var j=this.cache.length-1; j>0; j--)
				{
					if (this.cache[j].tile == s)
					{
						// not sure why this convoluted addition is necessary
						i = j+(spaces?1:0);
						t = j+(spaces?1:0);
						break;
					};
				};
				spaces++;
			};
		};
		
		this.body.size = Size(mw, this.texture.tileSize.height);
		
		var w = this.body.size.width;
		var pw = this.parent.body.size.width;
		if (this.alignment == TextMap.alignmentTypes.centered)
		{
		 	this.body.origin.x = pw/2 - w/2;
		}
		else if (this.alignment == TextMap.alignmentTypes.rightAligned)
		{
		 	this.body.origin.x = pw - w;
		};
		
		this.currentLength = -1;
		this.delayedElapsed = 0;
		this.delayDuration	= this.delay;
		this.hasFinished = NO;
	},
	advance : function()
	{
		this.currentLength = this.cache.length;
	},
	update : function(elapsed)
	{
		this.delayedElapsed += elapsed;
		
		if (this.delayedElapsed >= this.delayDuration && this.currentLength < this.cache.length)
		{
			this.currentLength++;
			this.delayedElapsed -= this.delayDuration;
		};
	},
	render : function()
	{
		var offset = this._relPos();
		for (var i=0; i<this.cache.length; i++)
		{
			if (i > this.currentLength && this.delayDuration) break;
			
			this.texture.drawTile(this.cache[i].tile+this.cache[i].offset,
				offset.x+this.cache[i].origin.x,
				offset.y+this.cache[i].origin.y);
		};
		
		if (this.currentLength >= this.cache.length)
		{
			this.hasFinished = YES;
		}
	}
});
TextMap.alignmentTypes =
{
	leftAligned 	: 0,
	rightAligned 	: 1,
	centered		: 2
};

// Input //////////////////////////////////////////////////////////////
var InputEvent = function(origin, type, key) { return {'type':type, 'origin':origin, 'key':key}; }; // types currently: began, moved, ended, keydown, keyup
var InputManager = Class.extend(
{
	init : function(target)
	{
		this.targets = [];
		this.hasTouch = NO;
		this.lastTouch = Point(0,0);
		
		addEvent(document, 'keydown', function(e){System.input.handleEvent(e)});
		addEvent(document, 'keyup', function(e){System.input.handleEvent(e)});
		
		addEvent(window, 'MozGamepadButtonDown', function(e){System.input.handleEvent(e)});
		addEvent(window, 'MozGamepadButtonUp', function(e){System.input.handleEvent(e)});
		addEvent(window, 'MozGamepadAxisMove', function(e){System.input.handleEvent(e)});
		
		addEvent(target, supportsTouch ? 'touchstart':'mousedown', function(e){System.input.handleEvent(e)});
		addEvent(target, supportsTouch ? 'touchmove':'mousemove', function(e){System.input.handleEvent(e)});
		addEvent(target, supportsTouch ? 'touchend':'mouseup', function(e){System.input.handleEvent(e)});
		if (supportsTouch) addEvent(target, 'touchcancel', function(e){System.input.handleEvent(e)});
	},
	pointInEvent : function(event)
	{
		var px = 0;
		var py = 0;
		if (event.touches && event.touches.length)
		{
			px = event.touches[0].pageX;
			py = event.touches[0].pageY;
		}
		else if (event.pageX == null && event.clientX != null)
		{
			var eventDocument = event.target.ownerDocument || document,
				doc = eventDocument.documentElement,
				body = eventDocument.body;

			px = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
			py = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
		}
		else
		{
			px = event.pageX;
			py = event.pageY;
		};

		var e = System.canvas;
		while (e.offsetParent)
		{
			px -= e.offsetLeft;
			py -= e.offsetTop;
			e = e.offsetParent;
		};

		if (System._zoom > 1)
		{
			px = Math.floor(px/System._zoom);
			py = Math.floor(py/System._zoom);
		};
		
		if (System._scale > 1)
		{
			px = Math.floor(px/System._scale);
			py = Math.floor(py/System._scale);
		};

		return Point(px, py);
	},
	handleEvent : function(event)
	{
		var origin = this.pointInEvent(event);
		var type;
		var key = InputManager.KEY.NONE;
		switch(event.type)
		{
			case 'MozGamepadAxisMove':
				if (event.axis == 0) // X
				{
					switch(event.value)
					{
						case -1: // left
							key = InputManager.KEY.LEFT;
							type = 'keydown';
							break;
						case 1: // right
							key = InputManager.KEY.RIGHT;
							type = 'keydown';
							break;
						default: // release
							key = this.xAxis == 1 ? InputManager.KEY.RIGHT : InputManager.KEY.LEFT;
							type = 'keyup';
							break;
					};
					this.xAxis = Math.round(event.value);
				}
				else // Y
				{
					switch(event.value)
					{
						case -1: // up
							key = InputManager.KEY.UP;
							type = 'keydown';
							break;
						case 1: // right
							key = InputManager.KEY.DOWN;
							type = 'keydown';
							break;
						default: // release
							key = this.yAxis == 1 ? InputManager.KEY.DOWN : InputManager.KEY.UP;
							type = 'keyup';
							break;
					};
					this.yAxis = Math.round(event.value);
				};
				break;
			case 'MozGamepadButtonDown':
				key = InputManager.KEY.ACTION;
				type = 'keyup';
				break;
			case 'MozGamepadButtonDown':
				key = InputManager.KEY.ACTION;
				type = 'keydown';
				break;
			case 'keydown':
			case 'keyup':
				// alert(event.keyCode);
				if (event.ctrlKey || event.metaKey) break;
				switch(event.keyCode)
				{
					case 87: // w
					case 38: // up
						key = InputManager.KEY.UP;
						break;
					case 68: // d
					case 39: // right
						key = InputManager.KEY.RIGHT;
						break;
					case 83: // s
					case 40: // down
						key = InputManager.KEY.DOWN;
						break;
					case 65: // a
					case 37: // left
						key = InputManager.KEY.LEFT;
						break;
					case 32 : // space
						key = InputManager.KEY.ACTION;
						break;
				}
				if (key!=InputManager.KEY.NONE) type = event.type;
				break;
			case 'mousedown':
			case 'touchstart':
				type = 'began';
				this.lastTouch 	= origin;
				this.hasTouch 	= YES;
				break;
			case 'mousemove':
			case 'touchmove':
				if (this.hasTouch) 
				{
					type = 'moved';
					this.lastTouch = origin;
				}
				else type = NO;
				break;
			case 'mouseup':
			case 'touchend':
			case 'touchcancel':
				this.hasTouch = NO;
				if (event.type == 'mouseup') // touchend and touchcancel don't provide pageX/pageY so leave existing value
				{
					this.lastTouch = origin;
				};
				type = 'ended';
				break;
			default:
				this.hasTouch = NO;
				type = NO;
		};
		
		if (type)
		{
			event.preventDefault();
			// send to targets
			for (var i in this.targets)
			{
				if (this.targets[i].handleEvent)
				{
					this.targets[i].handleEvent(InputEvent(origin,type,key));
				};
			};
		};
	},
	registerTarget : function(target)
	{
		this.targets.push(target);
	},
	unregisterTarget : function(target)
	{
		for (var i in this.targets)
		{
			if (this.targets[i] == target)
			{
				this.targets.splice(i,1);
				break;
			};
		};
	},
	unregisterAllTargets : function()
	{
		this.targets = [];
	}
});
InputManager.KEY =
{
	NONE	: -1,
	UP 		:  0,
	RIGHT 	:  1,
	DOWN 	:  2,
	LEFT 	:  3,
	ACTION 	:  4
};

// Speaker ////////////////////////////////////////////////////////////
var Sound = Class.extend( // don't use Sounds directly
{
	init : function(src)
	{
		this.src			= src;
		this.buffer 		= null; // cached
		this.source 		= null; // single-use
		this.isReady		= NO;
		this.isLoop			= NO;
		this.startTime 		= 0;
		this.loopTime		= 0;
		this.duration		= 0;
		this.onload			= null;
		this.timeoutId		= null;
		
		var sound = this;
		
		var request = new XMLHttpRequest();
		request.addEventListener('load', function(e)
		{
			System.speaker.context.decodeAudioData(request.response, function(decoded_data)
			{
				// cache
				sound.buffer 	= decoded_data;
				sound.duration	= sound.buffer.duration;
				sound.isReady	= YES;
				
				if (typeof sound.onload == 'function') sound.onload();
				
			}, function(e)
			{
				console.log(e);
			});
		}, false);

		request.open('GET', src, true);
		request.responseType = 'arraybuffer';
		request.send();
	},
	
	renewSource : function()
	{
		if (this.source)
		{
			this.source.noteOff(0);
			this.source = null;
		};
		
		this.source = System.speaker.context.createBufferSource();
		this.source.buffer = this.buffer;
		this.source.connect(System.speaker.context.destination);
	},
	
	play : function()
	{
		this.renewSource();
		this.source.noteOn(0);
		this.startTime = System.speaker.context.currentTime;
		this.loopTime = 0;
		
		if (this.isLoop) this.loop();
	},
	
	loop : function()
	{
		if (this.isLoop)
		{
			var sound = this;
			this.timeoutId = window.setTimeout(function()
			{
				sound.play();
				
			}, this.duration*1000);
		};
	},
	
	pause : function()
	{
		if (!this.isLoop) return;

		window.clearTimeout(this.timeoutId);
		this.loopTime += System.speaker.context.currentTime - this.startTime;
		this.source.noteOff(0);
	},
	
	resume : function()
	{
		if (!this.isLoop) return;

		var timeout = this.duration - this.loopTime;
		this.renewSource();
		this.source.noteGrainOn(0, this.loopTime, timeout);
		this.startTime = System.speaker.context.currentTime;
		
		var sound = this;
		this.timeoutId = window.setTimeout(function()
		{
			sound.play();
			
		}, timeout*1000);
	}
});
var Speaker = Class.extend(
{
	init : function()
	{
		this.sounds		= {}; // by src
		this.loopSrc	= '';
		
		this.context = NO;
		if (typeof AudioContext == "function")
		{
			this.context = new AudioContext();
		}
		else if (typeof webkitAudioContext == "function")
		{
			this.context = new webkitAudioContext();
		};
	},
	preload : function(srcs)
	{
		if (!this.context) return;
		
		for (var src in srcs)
		{
			if (!this.sounds[src])
			{
				var sound = new Sound(src);
				this.sounds[src] = sound;
			};
		};
	},
	
	play : function(src, isLoop)
	{
		var speaker = this;
		
		if (this.sounds[src]) // cached and ready
		{
			var sound = this.sounds[src];
			if (sound.isReady)
			{
				sound.isLoop = isLoop;
				sound.play();
			}
			else
			{
				sound.onload = function()
				{
					speaker.play(src, isLoop);
				};
			};
		}
		else // load then play
		{
			var sound = new Sound(src);
			sound.onload = function()
			{
				speaker.play(src, isLoop);
			};
			this.sounds[src] = sound;
		};
	},
	
	loop : function(src)
	{
		if (!this.context) return;
		if (this.loopSrc != src)
		{
			this.loopSrc = src;
			this.play(src, YES);
		};
	},
	
	pause : function()
	{
		if (!this.context) return;
		
		if (this.loopSrc && this.sounds[this.loopSrc])
		{
			this.sounds[this.loopSrc].pause();
		};
	},
	resume : function()
	{
		if (!this.context) return;
		
		if (this.loopSrc && this.sounds[this.loopSrc])
		{
			this.sounds[this.loopSrc].resume();
		};
	},
	
	fx : function(src)
	{
		if (!this.context) return;
		
		this.play(src, NO);
	}
});

// System /////////////////////////////////////////////////////////////
var GameSystem = Surface.extend(
{
	init : function(id, w, h)
	{
		this._super(0,0,w,h);
		this.RAM = {}; // global storage
		document.getElementById(id).innerHTML = '<canvas id="'+id+'-canvas" width="'+w+'" height="'+h+'"></canvas>';
		this.canvas = document.getElementById(id+'-canvas');
		this.zoom(1);
		this.scale(1);
		this.screen = this.canvas.getContext('2d');
		this.debug = document.getElementById('debug');
		
		this.speaker = new Speaker;

		this.input = new InputManager(this.canvas);
		
		this.fps = 0;
		this._fps = 0;
		this.second = 0;
		
		this.isPaused = NO;
		
		this.lastTime = (new Date()).getTime();
		this.loop();
		
		addEvent(window, 'blur', function(){System.pause();});
		addEvent(window, 'focus', function(){System.unpause();});
		
		if (window.devicePixelRatio && window.devicePixelRatio >= 2)
		{
			// trigger hi-res retina graphics by doubling window size
			// System.autozoom() then does the right thing
			document.getElementById('viewport').content = 'initial-scale=0.5;user-scalable=no';
		};
	},
	pause : function()
	{
		this.isPaused = YES;
		this.speaker.pause();
	},
	unpause : function()
	{
		if (this.isPaused)
		{
			this.isPaused = NO;
			this.speaker.resume();
			this.lastTime = (new Date()).getTime();
		};
	},
	zoom : function(z) // zoom with CSS, blurry in Safari
	{
		if (this._zoom == z) return;

		this._zoom = z;
		var p = 1/z*100;
		var w = z * this.body.size.width;
		var h = z * this.body.size.height;
		
		var css = '';
		var prefixes = ['','-webkit-','-moz-','-o-','-ms-'];
		for (var i=0; i<prefixes.length; i++)
		{
			var prefix = prefixes[i];
			if (prefix == '-webkit-')
			{
				css += 'zoom:'+z+';';
			}
			else
			{
				css += prefix+'transform: scale('+z+','+z+');'; // translateZ(0) not necessary, canvas is already hardware accelerated
				css += prefix+'transform-origin: 0 0;'
			};
		};
		this.canvas.style.cssText = css;
		this.canvas.parentNode.style.cssText = 'width:'+w*this._scale+'px;height:'+h*this._scale+'px;';
	},
	autozoom : function()
	{
		this._autozoom();
		addEvent(window, 'resize', function(){System._autozoom();});
	},
	_autozoom : function()
	{
		var wr = Math.floor(window.innerWidth / this.body.size.width);
		var hr = Math.floor(window.innerHeight / this.body.size.height);
		if (wr < 1) wr = 1;
		if (hr < 1) hr = 1;
		var scale = wr<hr?wr:hr;
		this.zoom(scale); 
	},
	scale : function(s) // scale on canvas, crisp in Safari, significant fps hit in Firefox/heat on retina device
	{
		if (this._scale == s) return;
		
		// compositing operations break down above a scale of 5 on retina iPad
		if (navigator.userAgent.match(/mobile/i) && navigator.userAgent.match(/webkit/i) && s > 5)
		{
			// TODO: hard code to 8?
			// iPad can accommodate x8 so scale to x4 then zoom x2
			s = 4;
			this._scale = s;
			this.zoom(2);
		};
		
		this._scale = s;
		var w = s * this.body.size.width;
		var h = s * this.body.size.height;
		this.canvas.width	= w;
		this.canvas.height	= h;
		this.canvas.parentNode.style.cssText = 'width:'+w*this._zoom+'px;height:'+h*this._zoom+'px;';
	},
	autoscale : function()
	{
		this._autoscale();
		addEvent(window, 'resize', function(){System._autoscale();});
	},
	_autoscale : function()
	{
		var wr = Math.floor(window.innerWidth / this.body.size.width);
		var hr = Math.floor(window.innerHeight / this.body.size.height);
		if (wr < 1) wr = 1;
		if (hr < 1) hr = 1;
		var scale = wr<hr?wr:hr;
		this.scale(scale); 
	},
	log : function(html)
	{
		this.debug.innerHTML = html + '\n' + this.debug.innerHTML;
	},
	loop : function()
	{
		if (this.isPaused) return requestAnimFrame(function(){System.loop();}, this.canvas);
		
		var now 		= (new Date()).getTime();
		var elapsed 	= (now - this.lastTime) / 1000;
		this.lastTime 	= now;
		
		this._fps++;
		var second = Math.floor(now/1000);
		if (second != this.second)
		{
			this.second = second;
			this.fps = this._fps;
			this._fps = 0;
		};
		// this.debug.innerHTML = this.fps+' fps';
		// this.debug.innerHTML = this._scale;
		
		this.update(elapsed);
		requestAnimFrame(function(){System.loop();}, this.canvas); // schedule next before render
		this.screen.clearRect(0,0,this.body.size.width*this._zoom*this._scale,this.body.size.height*this._zoom*this._scale);
		this.render();
	},
	screenshot : function()
	{
		return this.canvas.toDataURL();
	},
	state : function()
	{
		return this.children[0];
	},
	loadState : function(newState)
	{
		this.removeAllChildren();
		this.addChild(newState);
	}
});


// GAME BEGINS --------------------------------------------------------

// Utils //////////////////////////////////////////////////////////////
function zeroPad(num, len) {
	var str = num+'';
	
	while (str.length < len)
	{
		str = '0' + str;
	};
	return str;
};

function removeIndex(arr, index) {
	var retArr = [];
	for (var i in arr)
	{
		if (i == index) continue;
		retArr.push(arr[i]);
	};
	return retArr;
};

// http://dev.kanngard.net/Permalinks/ID_20030114184548.html
function contains(a, e) {
	for(j=0;j<a.length;j++)if(a[j]==e)return true;
	return false;
}

// quick JavaScript port of http://roguebasin.roguelikedevelopment.org/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels
// this dupes *a lot* of the Mapper function
var WaterMapper = function(tw,th)
{
	var TILE_WATER 	= 1;
	var TILE_FLOOR	= 0;

	var generationParams = function(_r1_cutoff, _r2_cutoff, _reps)
	{
		return {
			'r1_cutoff' : _r1_cutoff,
			'r2_cutoff' : _r2_cutoff,
			'reps' 		: _reps
		};
	};

	var grid	= [];
	var grid2 	= [];
	var open 	= [];
	
	var fillprob = 35;
	var r1_cutoff = 5;
	var r2_cutoff = 5;
	var size_x = tw;
	var size_y = th;
	var params 		= {};
	var params_set 	= [];
	var generations;

	var randpick = function()
	{
		return Math.random()*100 < fillprob ? TILE_FLOOR : TILE_WATER;
	};

	var initmap = function()
	{
		var xi;
		var yi;

		for (yi=0; yi<size_y; yi++)
		{
			grid [yi] = [];
			grid2[yi] = [];
		};

		for (yi=0; yi<size_y; yi++)
		{
			for (xi=0; xi<size_x; xi++)
			{
				grid [yi][xi] = randpick();
			};
		};
	};

	var generation = function()
	{
		var xi, yi, ii, jj;

		for(yi=1; yi<size_y-1; yi++)
		{
			for(xi=1; xi<size_x-1; xi++)
		 	{
		 		var adjcount_r1 = 0,
					adjcount_r2 = 0;

		 		for(ii=-1; ii<=1; ii++)
				{
					for(jj=-1; jj<=1; jj++)
			 		{
			 			if(grid[yi+ii][xi+jj] != TILE_WATER)
			 				adjcount_r1++;
			 		};
				};

		 		for(ii=yi-2; ii<=yi+2; ii++)
				{
			 		for(jj=xi-2; jj<=xi+2; jj++)
			 		{
			 			if(Math.abs(ii-yi)==2 && Math.abs(jj-xi)==2) continue;
			 			if(ii<0 || jj<0 || ii>=size_y || jj>=size_x) continue;
			 			if(grid[ii][jj] != TILE_WATER)
						{
							adjcount_r2++;
						};
			 		};
				};
		 		if(adjcount_r1 >= params.r1_cutoff || adjcount_r2 <= params.r2_cutoff)
				{
					grid2[yi][xi] = TILE_FLOOR;
				}
				 else
				{
					grid2[yi][xi] = TILE_WATER;
				};
		 	};	
		};

	 	for(yi=1; yi<size_y-1; yi++)
		{
		 	for(xi=1; xi<size_x-1; xi++)
			{
		 		grid[yi][xi] = grid2[yi][xi];		
			};
		};	
	};
	
	// generate
	initmap();

	params_set.push(generationParams(r1_cutoff,r2_cutoff,4));
	params_set.push(generationParams(r1_cutoff,0,3));
	generations = params_set.length;

	var ii, jj;
	for(ii=0; ii<generations; ii++)
	{
		params = params_set[ii];
		for(jj=0; jj<params.reps; jj++)
		{
			generation();
		};
	};
	
	return grid; // y arrays of xs
};

// this is so dirty, I don't _really_ understand how it works
var Mapper = function(tw,th)
{
	var TILE_FLOOR 	= 0;
	var TILE_WALL	= 1;

	var generationParams = function(_r1_cutoff, _r2_cutoff, _reps)
	{
		return {
			'r1_cutoff' : _r1_cutoff,
			'r2_cutoff' : _r2_cutoff,
			'reps' 		: _reps
		};
	};

	var grid	= [];
	var grid2 	= [];
	var open 	= [];
	
	var fillprob = 40;
	var r1_cutoff = 5;
	var r2_cutoff = 2;
	var size_x = tw;
	var size_y = th;
	var params 		= {};
	var params_set 	= [];
	var generations;

	var randpick = function()
	{
		return Math.random()*100 < fillprob ? TILE_WALL : TILE_FLOOR;
	};

	var initmap = function()
	{
		var xi;
		var yi;

		for (yi=0; yi<size_y; yi++)
		{
			grid [yi] = [];
			grid2[yi] = [];
		};

		for (yi=1; yi<size_y-1; yi++)
		{
			for (xi=1; xi<size_x-1; xi++)
			{
				grid [yi][xi] = randpick();
			};
		};

		for (yi=0; yi<size_y; yi++)
		{
			for (xi=0; xi<size_x; xi++)
			{
				grid2[yi][xi] = TILE_WALL;

			};
		};

		for (yi=0; yi<size_y; yi++)
		{
			grid [yi][0] = grid [yi][size_x-1] = TILE_WALL;
		};
		for (xi=0; xi<size_x; xi++)
		{
			grid [0][xi] = grid [size_y-1][xi] = TILE_WALL;
		};
	};

	var generation = function()
	{
		var xi, yi, ii, jj;

		for(yi=1; yi<size_y-1; yi++)
		{
			for(xi=1; xi<size_x-1; xi++)
		 	{
		 		var adjcount_r1 = 0,
					adjcount_r2 = 0;

		 		for(ii=-1; ii<=1; ii++)
				{
					for(jj=-1; jj<=1; jj++)
			 		{
			 			if(grid[yi+ii][xi+jj] != TILE_FLOOR)
			 				adjcount_r1++;
			 		};
				};

		 		for(ii=yi-2; ii<=yi+2; ii++)
				{
			 		for(jj=xi-2; jj<=xi+2; jj++)
			 		{
			 			if(Math.abs(ii-yi)==2 && Math.abs(jj-xi)==2) continue;
			 			if(ii<0 || jj<0 || ii>=size_y || jj>=size_x) continue;
			 			if(grid[ii][jj] != TILE_FLOOR)
						{
							adjcount_r2++;
						};
			 		};
				};
		 		if(adjcount_r1 >= params.r1_cutoff || adjcount_r2 <= params.r2_cutoff)
				{
					grid2[yi][xi] = TILE_WALL;
				}
				 else
				{
					grid2[yi][xi] = TILE_FLOOR;
				};
		 	};	
		};

	 	for(yi=1; yi<size_y-1; yi++)
		{
		 	for(xi=1; xi<size_x-1; xi++)
			{
		 		grid[yi][xi] = grid2[yi][xi];		
			};
		};	
	};
	
	// generate
	initmap();

	params_set.push(generationParams(r1_cutoff,r2_cutoff,4));
	params_set.push(generationParams(r1_cutoff,0,3));
	generations = params_set.length;

	var ii, jj;
	for(ii=0; ii<generations; ii++)
	{
		params = params_set[ii];
		for(jj=0; jj<params.reps; jj++)
		{
			generation();
		};
	};

	// identify open cell coordinates
	for (var y=0; y<size_y; y++)
	{
		for (var x=0; x<size_x; x++)
		{
			if (grid[y][x] == TILE_FLOOR) open.push([x,y]);
		};
	};
	
	// random start and end points
	var start 	= -1;
	var end 	= -1;
	var isSolvable = NO;
	
	while (!isSolvable)
	{
		start 	= Math.floor(Math.random()*open.length);
		end 	= Math.floor(Math.random()*open.length);
		key		= Math.floor(Math.random()*open.length);
		var epath = AStar(grid,open[start],open[end]);
		var kpath = AStar(grid,open[key],open[end]);
		if (kpath.length > 64 && epath.length > 64) isSolvable = YES;
	};
	
	var water = WaterMapper(tw,th);
	// eliminate water behind walls
	for (var y=0; y<size_y; y++)
	{
		for (var x=0; x<size_x; x++)
		{
			if (grid[y][x] == TILE_WALL) water[y][x] = TILE_FLOOR;
		};
	};
	// then open up around the starting point
	var sx = open[start][0];
	var sy = open[start][1];
	water[sy-1][sx] = TILE_FLOOR;
	water[sy][sx-1] = TILE_FLOOR;
	water[sy][sx] 	= TILE_FLOOR;
	water[sy][sx+1] = TILE_FLOOR;
	water[sy+1][sx] = TILE_FLOOR;
	
	return {
		'grid' 	: grid, 	// y arrays of xs
		'water'	: water, 	// y arrays of xs
		'open'	: open, 	// array of x,y coordinates
		'start' : start,	// index in open array
		'end'	: end,		// index in open array
		'key'	: key		// index in open array
	};
};


// Surfaces ///////////////////////////////////////////////////////////
var HUDNumber = Surface.extend(
{
	init : function(x,y)
	{
		this._super(x,y,13,7);
		this.number 	= 0;
		this.texture 	= new Texture('images/hud-nums.png', 7, 7);
	},
	render : function()
	{
		if (this.number > 99) this.number = 99;
		var tens = Math.floor(this.number/10);
		var ones = this.number - (tens*10);
		
		this.texture.drawTile(tens?tens:ones, this.body.origin.x, this.body.origin.y);
		if (tens)this.texture.drawTile(ones, this.body.origin.x+6, this.body.origin.y);
	}
});

var Minimap = Surface.extend(
{
	init : function(x,y,w,h,tiles)
	{
		this._super(x,y,w*tiles[0].length,h*tiles.length);
		this.tiles = tiles; // 0 ground, 1 wall
		
		this.reveal = []; // 0 empty, 1 opaque
		for (var y=0; y<this.tiles.length; y++)
		{
			this.reveal[y] = [];
			for (var x=0; x<this.tiles[y].length; x++)
			{
				this.reveal[y][x] = 0;
			};
		};
		
		this.isDisabled = NO;
	},
	render : function()
	{
		if (this.isDisabled) return;
		
		var x = 0;
		var y = 0;
		var s = System._scale;
		
		while (x < this.tiles[0].length)
		{
			y = 0;
			while (y < this.tiles.length)
			{
				if (this.reveal[y][x] == 1)
				{
					System.screen.fillStyle = this.tiles[y][x]?'#00746c':'#00e8d8'; // dark/light teal
					System.screen.fillRect((this.body.origin.x+x)*s,(this.body.origin.y+y)*s,s,s);
				};
				y++;
			};
			x++;
		};
	}
});

var Throbber = Sprite.extend(
{
	init : function(x,y,w,h,src)
	{
		this._super(x,y,w,h,src);
		this.sequences = 
		{
			'throb' 		: [0,1,2,1]
		};
		this.currentSequence = 'throb';
	}
});

var Meter = Surface.extend(
{
	init : function(x,y)
	{
		this._super(x,y,16,3);
		this.value = 1.0;
	},
	updateValue : function(value)
	{
		this.value = value;
		if (this.value<0) this.value = 0;
		if (this.value>1) this.value = 1;
	},
	render : function()
	{
		var crop = this._crop();
		var x = Math.round(this.body.origin.x-crop.origin.x);
		var y = Math.round(this.body.origin.y-crop.origin.y);
		var s = System._scale;
		
		// outline
		System.screen.fillStyle = '#000'; // black
		System.screen.fillRect(x*s,y*s,this.body.size.width*s,this.body.size.height*s);
		
		// inset
		System.screen.fillStyle = '#004058'; // dark blue
		System.screen.fillRect((x+1)*s,(y+1)*s,14*s,s);
		
		// bar
		var w = Math.round(this.value*14);
		System.screen.fillStyle = '#fce0a8'; // yellow
		System.screen.fillRect((x+1+(14-w))*s,(y+1)*s,w*s,s);
	}
});

// Entities ///////////////////////////////////////////////////////////
var Player = Sprite.extend(
{
	init : function(x,y)
	{
		this._super(x,y,16,16,'images/tomo.png');
		
		this.vx = 0;
		this.vy = 0;
		
		// used for beam direction, field of vision rectangle, and animation
		this.facing = 2; // 0=up,1=right,2=down,3=left
		this.lightsource = 0; // 0=none,1=flashlight,2=matches
		
		this.sequences = 
		{
			'stand'			: [10,10,10,10,10,10,10,10,11,11,12,12,12,12,13,13,13,13,12,12,12,12],
			'face-up' 		: [0],
			'face-right'	: [2],
			'face-down'		: [4],
			'face-left'		: [6],
			
			'walk-up'		: [0,1],
			'walk-right'	: [2,3],
			'walk-down'		: [4,5],
			'walk-left'		: [6,7],
			
			'climb'			: [8,9],
			
			'dead'			: [10]
		};
		this.currentSequence = 'face-down';
		
		this.isClimbing = NO;
		this.isDead		= NO;
		this.isInWater	= NO;
		
		this.isStanding = NO;
	},
	stand : function()
	{
		this.currentSequence = 'stand';
		this.isStanding = YES;
		this.shouldPlayOnce = YES;
	},
	move : function()
	{
		this.isStanding = NO;
		this.shouldPlayOnce = NO;
	},
	climb : function()
	{
		if (this.isClimbing) return;
		
		this.isClimbing = YES;
		this.vy = -16;
		
		System.state().queueDialog(localize('Up I go...'));
	},
	die : function()
	{
		if (this.isClimbing) return; // invincible bitches!
		
		this.isDead = YES;
		this.vx = 0;
		this.vy = 0;
		
		System.state().queueDialog(localize('Ugh!'));
	},
	revive : function()
	{
		this.isDead = NO;
	},
	view : function() // only used by Stalker currently
	{
		var w = this.body.size.width;
		var h = this.body.size.height;
		var x = this.body.origin.x;
		var y = this.body.origin.y;
		
		var view;
		switch(this.lightsource)
		{
			case 2: // flashlight, 3 wide, 3 deep
				switch(this.facing)
				{
					case 0: // up
						x -= w;
						y -= h*3;
						break;
					case 1: // right
						x += w;
						y -= h;
						break;
					case 2: // down
						x -= w;
						y += h;
						break;
					case 3: // left
						x -= w*3;
						y -= h;
						break;
				};
				
				w *= 3;
				h *= 3;
				
				view = Rect(x,y,w,h);
				break;
			case 1: // matches, 2 wide, 1 deep
				if (this.facing == 0 || this.facing == 2) // wide
				{
					x -= w/2;
					w *= 2;
					
					if (this.facing == 0) // up
					{
						y -= h;
					}
					else
					{
						y += h;
					};
				}
				else // tall
				{
					y -= h/2;
					h *= 2;
					
					if (this.facing == 1) // right
					{
						x += w;
					}
					else
					{
						x -= w;
					};
				};
				view = Rect(x,y,w,h);
				break;
			default: // no source of light, no protection
				view = Rect(0,0,0,0);
				break;
		};
		return view;
	},
	update : function(elapsed)
	{
		if (this.isStanding)
		{
			if (this.currentFrame == this.sequences['stand'].length-1)
			{
				this.move(); // triggers appropriate lightsource
			};
		}
		else
		{
			var seq = (this.vx || this.vy) ? 'walk-' : 'face-';
			switch(this.facing)
			{
				case 0:
					seq += 'up';
					break;
				case 1:
					seq += 'right';
					break;
				case 2:
					seq += 'down';
					break;
				case 3:
					seq += 'left';
					break;
			};
			this.frameOffset = this.isInWater ? 16 : 0;
			if (this.isClimbing) seq = 'climb';
			if (this.isDead) seq = 'dead';
			this.currentSequence = seq;
		};		
		this._super(elapsed);
	}
});

var Slasher = Sprite.extend(
{
	init : function()
	{
		this._super(0,0,16,24,'images/slash.png');
		this.sequences = 
		{
			'slash' 		: [0,1,1,2,2,2,3,]
		};
		this.currentSequence = 'slash';
		this.shouldPlayOnce = YES;
		this.frameDuration = 0.1;
		System.speaker.fx('audio/slash.ogg');
	}
});

var Stalker = Sprite.extend(
{
	init : function()
	{
		this._super(0,0,18,15,'images/alert.png');
		
		this.sequenceNames =
		[
			'growl',
			'snap',
			'hiss',
			'screech'
		];
		this.sequences = 
		{
			'growl' 		: [1,0],
			'snap'			: [2,0],
			'hiss'			: [3,0],
			'screech'		: [4,0]
		};
		this.frameDuration		= 1.0;
		this.currentSequence 	= this.sequenceNames[Math.floor(Math.random()*this.sequenceNames.length)];
		this.shouldPlayOnce 	= YES;

		this.dormantPeriod 	= 20 + Math.random()*4;
		this.dormantElapsed = 0;
		
		this.vx = 0;
		this.vy = 0;
		
		this.stalkSpeed		= 24;
		this.stalkPeriod 	= 2;
		this.stalkElapsed 	= 0;

		this.isVisible = NO;
		this.stalkee = null;
	},
	update : function(elapsed)
	{
		this.dormantElapsed += elapsed;
		this.stalkElapsed += elapsed;
		
		if (this.isVisible)
		{
			var s = this.stalkee.center();
			var c = this.center();

			var shouldStalk = YES;
			switch (this.stalkee.facing)
			{
				case 0: // up
					if (c.y < s.y) shouldStalk = NO;
					break;
				case 1: // right
					if (c.x > s.x) shouldStalk = NO;
					break;
				case 2: // down
					if (c.y > s.y) shouldStalk = NO;
					break;
				case 3: // left
					if (c.x < s.x) shouldStalk = NO;
					break;
			};
			
			if (!this.stalkee.lightsource) shouldStalk = YES; // lights out! go! go! go!
			
			if (shouldStalk)
			{
				var d = Point(s.x-c.x, s.y-c.y);
				var ad = Point(Math.abs(d.x), Math.abs(d.y));
				var adjustedStalkSpeed = this.stalkSpeed;
				
				switch(this.stalkee.lightsource)
				{
					case 1: // flashlight
						adjustedStalkSpeed *= 1.0;
					break;
					case 2: // matches
						adjustedStalkSpeed *= 0.7;
					break;
					case 0:
						adjustedStalkSpeed *= 0.4;
					break;
				};
				
				if (ad.x > ad.y)
				{
					this.vx = d.x > 0 ? adjustedStalkSpeed : -adjustedStalkSpeed;
					this.vy = 0;
				}
				else
				{
					this.vx = 0;
					this.vy = d.y > 0 ? adjustedStalkSpeed : -adjustedStalkSpeed;
				};
			}
			else
			{
				// deer in headlights
				this.vx = 0;
				this.vy = 0;
			};
			
			if (rectIntersectsRect(this.stalkee.view(), this.body))
			{
				this.flee();
			};
		}
		else if (this.dormantElapsed >= this.dormantPeriod)
		{
			this.stalk();
		};
		
		var p = this.body.origin
		this.body.origin = Point(p.x+this.vx*elapsed, p.y+this.vy*elapsed);
		
		if (this.isVisible && rectContainsPoint(this.body, this.stalkee.center()))
		{
			this.flee();
			var slasher = new Slasher();
			slasher.center(this.stalkee.center());
			this.parent.addChild(slasher);
			System.state().kill();
		};
		
		this._super(elapsed);
	},
	stalk : function()
	{
		// randomly position at edge of crop
		// but outside of the player's view
		var crop = this._crop();
		var isInPlayerView = YES;
		var view = this.stalkee.view();
		
		var p;
		while (isInPlayerView)
		{
			var rx = Math.random()*crop.size.width + crop.origin.x;
			var ry = Math.random()*crop.size.height + crop.origin.y;
			this.center(Point(rx, ry));
			if (!rectIntersectsRect(view, this.body))
			{
				isInPlayerView = NO;
			}
		};
		this.isVisible = YES;
		this.stalkElapsed = 0;

		this.currentSequence 	= this.sequenceNames[Math.floor(Math.random()*this.sequenceNames.length)];
		this.currentFrame = 0;
		this.sequenceElapsed = 0;
		
		System.state().queueDialog(localize('What was that!'));
		System.speaker.fx('audio/stalker.ogg');
	},
	flee : function()
	{
		this.isVisible = NO;
		this.dormantElapsed = 0;
		System.speaker.fx('audio/flee.ogg');
		
		System.state().queueDialog(localize('I must be hearing things...'));
		
		if (this.parent.children.length >= 8) return;
		
		var junior = new Stalker();
		junior.dormantPeriod = this.dormantPeriod*0.75 + Math.random()*4;
		junior.stalkSpeed  = this.stalkSpeed + Math.random()*this.stalkSpeed*0.25;
		if (junior.stalkSpeed > 48) junior.stalkSpeed = 48; // throttle to player speed
		junior.stalkee = this.stalkee;
		this.parent.addChild(junior);
	}
})

var Vine = Surface.extend(
{
	init : function(x,y)
	{
		this._super(x,y,16,16);
		// this.addChild(new Rectangle(x,y,16,16,'rgb(200,0,0)'));
		this.addChild(new Tile(x+2,y-40,12,56,'images/vine.png'));
	}
});

var Compass = Throbber.extend(
{
	init : function(x,y)
	{
		this._super(x+2,y+2,12,11,'images/compass.png');
	}
});

var Battery = Throbber.extend(
{
	init : function(x,y)
	{
		this._super(x+4,y+2,8,12,'images/battery.png');
	}
});

var Matchbook = Throbber.extend(
{
	init : function(x,y)
	{
		this._super(x+1,y+3,13,10,'images/matchbook.png');
	}
});

var Talisman = Throbber.extend(
{
	init : function(x,y)
	{
		this._super(x+3,y+2,10,12,'images/talisman.png');
	}
});

var Campfire = Sprite.extend(
{
	init : function(x,y)
	{
		this._super(x,y,16,16,'images/campfire.png');
		this.sequences = 
		{
			'idle'		: [0],
			'burn' 		: [3,4]
		};
		this.currentSequence = 'burn';
		this.frameDuration = 0.1;
	}
});

// Font ///////////////////////////////////////////////////////////////
var SentrySans = TextMap.extend(
{
	init : function()
	{
		this._super();
		this.texture = new Texture('images/sentry-sans+katakana.png',8,10);
		
		var chars = ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!?\'" ').split('');
		this.chars = {};
		for (var i=0; i<chars.length; i++)
		{
			this.chars[chars[i]] = i;
		};
		this.charWidth = 5; // default
		this.charWidthMap = 
		[
			'', 			// 0
			'', 			// 1
			'il.,!'+"'", 	// 2
			' ', 			// 3
			'Ifjtx1"',	// 4
			'', 			// 5 (default)
			'MNTVWXYZmvw',	// 6
			'',		// 7
			'',	// 8
		];
		this.charWidths = {};
		for (var i=0; i<this.charWidthMap.length; i++)
		{
			if (this.charWidthMap[i] == '') continue;
			var chars = this.charWidthMap[i].split('');
			for (var j=0; j<chars.length; j++)
			{
				this.charWidths[chars[j]] = i;
			};
		};
		this.offsetSize = 160;
		this.delay = 0.06;
	}
});


// States /////////////////////////////////////////////////////////////
var PlayState = State.extend(
{
	disableMinimap : function(isDisabled)
	{
		this.minimap.isDisabled = isDisabled;
	},
	init : function()
	{
		this._super();

		this.hasFoundExit = NO;
		this.isEnding = NO;
		this.isKilling = NO;
		this.isPaused = NO;
		this.isGameOver = NO;
		
		this.joystick = Point(0,0);
		
		// static properties
		this.batteryDuration 	= 60; 	// not the freshes batteries
		this.batteryDelay 		= 2;	// changing batteries takes a while
		this.matchDuration 		= 3;	// burns down fast
		this.matchDelay			= 1; 	// time to strike
		
		this.lightsourceBattery	= 2;
		this.lightsourceMatch 	= 1;
		this.lightsourceEyes 	= 0;
		this.lightsourceNone 	= -1;		
		
		// inventory
		if (!System.RAM['inventory'])
		{
			System.RAM.inventory =
			{
				talismanCount		: 3,
				batteryCount 		: 3, // drops to 2 instantly
				matchCount			: 4, // per matchbook
				elapsedLight		: 0,
				lightDuration		: 0,
				lightsource			: this.lightsourceNone
			};
		};
		
		this.talismanCount 	= System.RAM.inventory.talismanCount;
		this.batteryCount 	= System.RAM.inventory.batteryCount;
		this.matchCount 	= System.RAM.inventory.matchCount;
		this.elapsedLight 	= System.RAM.inventory.elapsedLight;
		this.lightDuration	= System.RAM.inventory.lightDuration;
		this.lightsource	= System.RAM.inventory.lightsource;
		
		if (!System.RAM['level'])
		{
			System.RAM.level = 1;
		};
		
		this.room = new Surface();
		this.room.zIndex = 0;
		this.room.crop = System.body;
		this.addChild(this.room);
		
		this.hud = new Surface();
		this.hud.zIndex = 1;
		this.hud.addChild(new Tile(0,0,240,160,'images/hud.png'));
		this.addChild(this.hud);
		
		this.data = Mapper(60,40);
		var tiles = clone(this.data.grid);
		// autotile walls
		for (var y=0; y<tiles.length; y++)
		{
			for (var x=0; x<tiles[y].length; x++)
			{

				if (!tiles[y][x]) continue; // ignore floor for now
				
				var hasAbove = YES;
				var hasRight = YES;
				var hasBelow = YES;
				var hasLeft = YES;
				
				if (y>0 && !tiles[y-1][x]) hasAbove = NO;
				if (x<tiles[y].length-1 && !tiles[y][x+1]) hasRight = NO;
				if (y<tiles.length-1 && !tiles[y+1][x]) hasBelow = NO;
				if (x>0 && !tiles[y][x-1]) hasLeft = NO;
				
				if (!hasAbove && hasRight && hasBelow && hasLeft)
				{
					tiles[y][x] = 2; // edge up
				}
				else if (hasAbove && !hasRight && hasBelow && hasLeft)
				{
					tiles[y][x] = 3; // edge right
				}
				else if (hasAbove && hasRight && !hasBelow && hasLeft)
				{
					tiles[y][x] = 4; // edge bottom
				}
				else if (hasAbove && hasRight && hasBelow && !hasLeft)
				{
					tiles[y][x] = 5; // edge left
				}
				else if (hasAbove && !hasRight && hasBelow && !hasLeft)
				{
					tiles[y][x] = 6; // vertical
				}
				else if (!hasAbove && hasRight && !hasBelow && hasLeft)
				{
					tiles[y][x] = 7; // horizontal
				}
				else if (!hasAbove && !hasRight && hasBelow && !hasLeft)
				{
					tiles[y][x] = 8; // cap up
				}
				else if (!hasAbove && !hasRight && !hasBelow && hasLeft)
				{
					tiles[y][x] = 9; // cap right
				}
				else if (hasAbove && !hasRight && !hasBelow && !hasLeft)
				{
					tiles[y][x] = 10; // cap down
				}
				else if (!hasAbove && hasRight && !hasBelow && !hasLeft)
				{
					tiles[y][x] = 11; // cap left
				}
				else if (!hasAbove && hasRight && hasBelow && !hasLeft)
				{
					tiles[y][x] = 12; // corner top left
				}
				else if (!hasAbove && !hasRight && hasBelow && hasLeft)
				{
					tiles[y][x] = 13; // corner top right
				}
				else if (hasAbove && !hasRight && !hasBelow && hasLeft)
				{
					tiles[y][x] = 14; // corner bottom right
				}
				else if (hasAbove && hasRight && !hasBelow && !hasLeft)
				{
					tiles[y][x] = 15; // corner bottom left
				}
				else if (!hasAbove && !hasRight && !hasBelow && !hasLeft)
				{
					tiles[y][x] = 16; // standalone
				}
			};
		};
		this.map = new TileMap(0,0,16,16,'images/tiles.png',tiles);
		this.room.addChild(this.map);
		
		var water = clone(this.data.water);
		// autotile water
		for (var y=0; y<water.length; y++)
		{
			for (var x=0; x<water[y].length; x++)
			{
				if (!water[y][x]) continue; // ignore empty tiles
				
				// has refers to ground not  water (so the water's edge)
				var hasAbove = NO;
				var hasRight = NO;
				var hasBelow = NO;
				var hasLeft = NO;
				
				if (y>0 && !water[y-1][x]) hasAbove = YES;
				if (x<water[y].length-1 && !water[y][x+1]) hasRight = YES;
				if (y<water.length-1 && !water[y+1][x]) hasBelow = YES;
				if (x>0 && !water[y][x-1]) hasLeft = YES;
				
				var hasCornerAL = NO;
				var hasCornerAR = NO;
				var hasCornerBL = NO;
				var hasCornerBR = NO;
				
				if (y>0) // above corners
				{
					if (x>0 && !water[y-1][x-1]) hasCornerAL = YES;
					if (x<water[y-1].length-1 && !water[y-1][x+1]) hasCornerAR = YES;
				};
				
				if (y<water.length-1) // below
				{
					if (x>0 && !water[y+1][x-1]) hasCornerBL = YES;
					if (x<water[y+1].length-1 && !water[y+1][x+1]) hasCornerBR = YES;
				};
				
				// four closed
				if (hasAbove && hasRight && hasBelow && hasLeft)
				{
					water[y][x] = 36;
				}
				
				// three closed
				else if (hasAbove && hasRight && !hasBelow && hasLeft)
				{
					water[y][x] = 6;
				}
				else if (hasAbove && hasRight && hasBelow && !hasLeft)
				{
					water[y][x] = 7;
				}
				else if (!hasAbove && hasRight && hasBelow && hasLeft)
				{
					water[y][x] = 8;
				}
				else if (hasAbove && !hasRight && hasBelow && hasLeft)
				{
					water[y][x] = 9;
				}
				
				// two closed, parallel
				else if (!hasAbove && hasRight && !hasBelow && hasLeft)
				{
					water[y][x] = 10;
				}
				else if (hasAbove && !hasRight && hasBelow && !hasLeft)
				{
					water[y][x] = 11;
				}
				
				// two closed, perpendicular
				else if (hasAbove && !hasRight && !hasBelow && hasLeft)
				{
					if (hasCornerBR)
					{
						water[y][x] = 16;
					}
					else
					{
						water[y][x] = 12;
					};
				}
				else if (hasAbove && hasRight && !hasBelow && !hasLeft)
				{
					if (hasCornerBL)
					{
						water[y][x] = 17;
					}
					else
					{
						water[y][x] = 13;
					};
				}
				else if (!hasAbove && !hasRight && hasBelow && hasLeft)
				{
					if (hasCornerAR)
					{
						water[y][x] = 18;
					}
					else
					{
						water[y][x] = 14;
					};
				}
				else if (!hasAbove && hasRight && hasBelow && !hasLeft)
				{
					if (hasCornerAL)
					{
						water[y][x] = 19;
					}
					else
					{
						water[y][x] = 15;
					};
				}
				
				// one closed
				else if (hasAbove && !hasRight && !hasBelow && !hasLeft)
				{
					if (hasCornerBL && hasCornerBR)
					{
						water[y][x] = 32;
					}
					else if (hasCornerBL)
					{
						water[y][x] = 29;
					}
					else if (hasCornerBR)
					{
						water[y][x] = 28;
					}
					else
					{
						water[y][x] = 2;
					}
				}
				else if (!hasAbove && hasRight && !hasBelow && !hasLeft)
				{
					if (hasCornerAL && hasCornerBL)
					{
						water[y][x] = 33;
					}
					else if (hasCornerAL)
					{
						water[y][x] = 27;
					}
					else if (hasCornerBL)
					{
						water[y][x] = 25;
					}
					else
					{
						water[y][x] = 3;
					}
				}
				else if (!hasAbove && !hasRight && hasBelow && !hasLeft)
				{
					if (hasCornerAL && hasCornerAR)
					{
						water[y][x] = 34;
					}
					else if (hasCornerAL)
					{
						water[y][x] = 31;
					}
					else if (hasCornerAR)
					{
						water[y][x] = 30;
					}
					else
					{
						water[y][x] = 4;
					}
				}
				else if (!hasAbove && !hasRight && !hasBelow && hasLeft)
				{
					if (hasCornerAR && hasCornerBR)
					{
						water[y][x] = 35;
					}
					else if (hasCornerAR)
					{
						water[y][x] = 26;
					}
					else if (hasCornerBR)
					{
						water[y][x] = 24;
					}
					else
					{
						water[y][x] = 5;
					}
				}
				// no closed
				else if (!hasAbove && !hasRight && !hasBelow && !hasLeft)
				{
					// four corners
					if (hasCornerAL && hasCornerAR && hasCornerBL && hasCornerBR)
					{
						water[y][x] = 37;
					}
					
					// three corners
					else if (hasCornerAL && hasCornerAR && !hasCornerBL && hasCornerBR)
					{
						water[y][x] = 38;
					}
					else if (hasCornerAL && hasCornerAR && hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 39;
					}
					else if (!hasCornerAL && hasCornerAR && hasCornerBL && hasCornerBR)
					{
						water[y][x] = 40;
					}
					else if (hasCornerAL && !hasCornerAR && hasCornerBL && hasCornerBR)
					{
						water[y][x] = 41;
					}
					
					// two corners, opposite
					else if (hasCornerAL && !hasCornerAR && !hasCornerBL && hasCornerBR)
					{
						water[y][x] = 42;
					}
					else if (!hasCornerAL && hasCornerAR && hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 43;
					}
					
					// two corners, adjacent
					else if (hasCornerAL && hasCornerAR && !hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 44;
					}
					else if (!hasCornerAL && hasCornerAR && !hasCornerBL && hasCornerBR)
					{
						water[y][x] = 45;
					}
					else if (!hasCornerAL && !hasCornerAR && hasCornerBL && hasCornerBR)
					{
						water[y][x] = 46;
					}
					else if (hasCornerAL && !hasCornerAR && hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 47;
					}
					
					// one corner
					else if (!hasCornerAL && !hasCornerAR && !hasCornerBL && hasCornerBR)
					{
						water[y][x] = 20;
					}
					else if (!hasCornerAL && !hasCornerAR && hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 21;
					}
					else if (!hasCornerAL && hasCornerAR && !hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 22;
					}
					else if (hasCornerAL && !hasCornerAR && !hasCornerBL && !hasCornerBR)
					{
						water[y][x] = 23;
					}
				};
			};
		};
		this.water = new TileMap(0,0,16,16,'images/tiles-water.png',water);
		this.room.addChild(this.water);
		this.waterElapsed = 0;
		
		this.exit = new Vine(this.data.open[this.data.end][0]*16,
								this.data.open[this.data.end][1]*16);
		this.exit.zIndex = 1;
		this.room.addChild(this.exit);
		
		this.compass = new Compass(this.data.open[this.data.key][0]*16,
								this.data.open[this.data.key][1]*16);
		this.room.addChild(this.compass);
		
		// random collectibles, not concerned with whether they are actually accessible to player
		this.collectibles = new Surface();
		var rb = 1 + Math.round(Math.random()*2); // 1-3 per level
		var rm = 6 + Math.round(Math.random()*4); // 6-10 per level
		
		// talismans
		if (Math.round(Math.random()))
		{
			var o = Math.floor(Math.random()*this.data.open.length);
			if (o == this.data.start || o == this.data.end || o == this.data.key)
			{
				// too lazy to rewrite the conditional. I know, right?
			}
			else
			{
				var talisman = new Talisman(this.data.open[o][0]*16,
											  this.data.open[o][1]*16);
				this.collectibles.addChild(talisman);
			};
		};
		
		// batteries
		for (var i=0; i<rb; i++)
		{
			var o = Math.floor(Math.random()*this.data.open.length);
			if (o == this.data.start || o == this.data.end || o == this.data.key) continue;
			
			var collectible = new Battery(this.data.open[o][0]*16,
										  this.data.open[o][1]*16);
			this.collectibles.addChild(collectible);
		};
		
		// matchbooks
		for (var i=0; i<rm; i++)
		{
			var o = Math.floor(Math.random()*this.data.open.length);
			if (o == this.data.start || o == this.data.end || o == this.data.key) continue;
			
			var collectible = new Matchbook(this.data.open[o][0]*16,
											this.data.open[o][1]*16);
			this.collectibles.addChild(collectible);
		};
		this.room.addChild(this.collectibles);
		
		
		var hole = new Tile(this.data.open[this.data.start][0]*16,
							this.data.open[this.data.start][1]*16,
							16,16,
							'images/vine-hole.png');
		hole.zIndex = 1;
		hole.currentTile = System.RAM.level > 1 ? 1 : 0;
		this.room.addChild(hole);
		
		this.player = new Player(this.data.open[this.data.start][0]*16,
								 this.data.open[this.data.start][1]*16);
		this.player.zIndex = 2;
		this.room.addChild(this.player);
		
		if (System.RAM.level==1)
		{
			this.player.stand();
		}
		
		this.mask = new Mask;
		this.mask.zIndex = 3;
		this.room.addChild(this.mask);

		this.beam = new Tile(0,0,132,132,'images/beam-mask.png');
		this.beam.currentTile = 9; // unadjusted eyes
		this.beam.center(this.player.center());
		this.mask.addChild(this.beam);
		// this.darkness = new Rectangle(0,0,480,320,'rgba(0,0,0,0.1)');
		// this.darkness.center(this.player.center());
		// this.mask.addChild(this.darkness);
		
		// this.mask.isVisible = NO;
		
		// stalkers, self-replicating
		this.stalkers = new Surface();
		this.stalkers.zIndex = 4;
		var stalker = new Stalker();
		stalker.stalkee = this.player;
		this.stalkers.addChild(stalker);
		this.room.addChild(this.stalkers);
		
		// light meter
		this.meter = new Meter(0,0);
		this.meter.zIndex = 5;
		this.room.addChild(this.meter);
		
		// hud
		this.batteryNum = new HUDNumber(11,11);
		this.hud.addChild(this.batteryNum);
		
		this.matchNum = new HUDNumber(31,11);
		this.hud.addChild(this.matchNum);

		this.talismanNum = new HUDNumber(64,11);
		this.hud.addChild(this.talismanNum);
		
		this.levelNum = new HUDNumber(32, 150);
		this.levelNum.number = System.RAM.level;
		this.hud.addChild(this.levelNum);
		
		this.frameNum = new HUDNumber(224, 48);
		// this.hud.addChild(this.frameNum);
		
		// this.scaleNum = new HUDNumber(212, 48);
		// this.scaleNum.number = System._scale;
		// this.hud.addChild(this.scaleNum);
		
		this.pauseRect = Rect(220,140,20,20);
		
		// mini map
		this.minimap = new Minimap(174,4,1,1, clone(this.data.grid));
		this.hud.addChild(this.minimap);
		
		this.miniplayer = new Tile(this.data.open[this.data.start][0]+this.minimap.body.origin.x-1,
								this.data.open[this.data.start][1]+this.minimap.body.origin.x-1,
								3,3,
								'images/miniplayer.png');
		this.hud.addChild(this.miniplayer);
		
		this.miniexit = new Tile(this.data.open[this.data.end][0]+this.minimap.body.origin.x-2,
								this.data.open[this.data.end][1]+this.minimap.body.origin.y-3,
								5,6,
								'images/minivine.png');
		this.miniexit.isVisible = NO;
		this.hud.addChild(this.miniexit);
		
		// touch point
		this.touch = new Tile(0,0,32,32,'images/touch.png');
		this.touch.isVisible = NO;
		this.hud.addChild(this.touch);
		
		// dialog
		this.sentry = new SentrySans;
		this.sentry.body.origin = Point(54, 149);
		this.hud.addChild(this.sentry); 
		
		this.pausedElapsed = 0;
		this.paused = new Tile(97,50,51,51,'images/paused.png');
		this.paused.isVisible = NO;
		this.addChild(this.paused);
		
		this.gameOverElapsed = 0;
		this.gameOver = new Tile(97,50,51,51,'images/gameover.png');
		this.gameOver.isVisible = NO;
		this.addChild(this.gameOver);
		
		this.dialogs = [];
		this.dialogElapsed = 0;
		
		switch (System.RAM.level)
		{
			case 1:
				this.queueDialog(localize('How did I survive that fall?'));
				this.queueDialog(localize('I need to find a way out of here.'));
				this.queueDialog(localize('My arm is definitely broken and'));
				this.queueDialog(localize('these batteries won\'t last forever...'));
				break;
			case 2:
				this.queueDialog(localize('I wonder how far down I am...'));
				break;
			case 3:
				this.queueDialog(localize('This is starting to look familiar.'));
				break;
		}
		
		System.input.registerTarget(this);
		
		// this.beam.isVisible = NO;
	},
	queueDialog : function(str)
	{
		if (contains(this.dialogs, str)) return;
		if (!this.dialogs.length) this.dialogElapsed = 10;
		this.dialogs.push(str);
	},
	displayNextDialog : function()
	{
		if (this.dialogs.length)
		{
			this.sentry.setText(this.dialogs.shift());
			this.dialogElapsed = 0;
		}
		else if (this.sentry.text)
		{
			this.sentry.setText('');
		};
	},
	kill : function()
	{
		if (this.isKilling) return;
		
		this.isKilling = YES;
		this.touch.isVisible = NO;

		this.talismanCount--;
		this.isGameOver = this.talismanCount < 0;
		if (this.isGameOver) this.talismanCount = 0; // can't display -1
		
		var player 		= this.player;
		var gameOver 	= this.gameOver;
		var isGameOver 	= this.isGameOver;
		window.setTimeout(function()
		{
			player.die();
			if (isGameOver) gameOver.isVisible = YES;
			window.setTimeout(function()
			{
				if (isGameOver)
				{
					System.state().gameover();
				}
				else
				{
					System.state().reset();
				}
			}, (isGameOver?5:2) * 1000);
		},  500);
	},
	gameover : function()
	{
		System.RAM['inventory'] = null;
		System.loadState(new TitleState);
	},
	reset : function()
	{
		
		// reset stalkers
		this.stalkers.removeAllChildren();
		var stalker = new Stalker();
		stalker.stalkee = this.player;
		this.stalkers.addChild(stalker);
		
		// reset collectibles (except compass which carries over)
		for (var i=0; i<this.collectibles.children.length; i++)
		{
			this.collectibles.children[i].isVisible = YES;
		};
		
		// reset player
		this.player.body.origin = Point(this.data.open[this.data.start][0]*16,
								 this.data.open[this.data.start][1]*16);
		this.player.revive();
		
		// reload inventory from RAM
		this.batteryCount 	= System.RAM.inventory.batteryCount;
		this.matchCount 	= System.RAM.inventory.matchCount;
		this.elapsedLight 	= System.RAM.inventory.elapsedLight;
		this.lightDuration	= System.RAM.inventory.lightDuration;
		this.lightsource	= System.RAM.inventory.lightsource;
		
		// reset dialog
		this.dialogs = [];
		
		// clear killing variables
		this.isKilling = NO;
	},
	clear : function()
	{
		this.isEnding = YES;
		this.touch.isVisible = NO;
		this.player.body.origin = clone(this.exit.body.origin);
		this.player.climb();
		
		System.RAM.inventory.talismanCount	= this.talismanCount;
		System.RAM.inventory.batteryCount	= this.batteryCount;
		System.RAM.inventory.matchCount		= this.matchCount;
		System.RAM.inventory.elapsedLight	= this.elapsedLight;
		System.RAM.inventory.lightDuration	= this.lightDuration;
		System.RAM.inventory.lightsource	= this.lightsource;
		
		// TODO: store total number of stalkers?
		
		window.setTimeout(function()
		{
			System.RAM.level++;
			System.loadState(new PlayState);
		}, 2 * 1000);
	},
	updateCamera : function()
	{
		var c = this.player.center();
		var o = Point(c.x-System.body.size.width/2, c.y-System.body.size.height/2);
		if (o.x < 0) o.x = 0;
		if (o.y < 0) o.y = 0;
		if (o.x+System.body.size.width > this.map.body.size.width) o.x = this.map.body.size.width-System.body.size.width;
		if (o.y+System.body.size.height > this.map.body.size.height) o.y = this.map.body.size.height-System.body.size.height;
		this.room.crop.origin = o;
	},
	update: function(elapsed)
	{
		this.frameNum.number = System.fps;
		if (this.isPaused) 
		{
			this.pausedElapsed += elapsed;
			
			var dur = 0.4;
			if (this.pausedElapsed >= dur)
			{
				this.paused.isVisible = !this.paused.isVisible;
				this.pausedElapsed -= dur;
			};
			return;
		};
		
		if (this.isGameOver) 
		{
			this.gameOverElapsed += elapsed;
			
			var dur = 0.4;
			if (this.gameOverElapsed >= dur)
			{
				this.gameOver.isVisible = !this.gameOver.isVisible;
				this.gameOverElapsed -= dur;
			};
			// return; // continue playing animations
		};
		
		this.waterElapsed += elapsed;
		if (this.waterElapsed > 0.4)
		{
			this.water.offset = this.water.offset?0:48;
			this.waterElapsed -= 0.4;
		};
		
		this.dialogElapsed += elapsed;
		if (this.dialogElapsed >= 4)
		{
			this.displayNextDialog();
		};
		
		if (this.isEnding)
		{
			this.meter.isVisible = NO;
			this.player.update(elapsed);
			this.sentry.update(elapsed);
			this.player.body.origin.y += this.player.vy*elapsed;
			this.beam.center(this.player.center());
			return;
		};
		this._super(elapsed);
		
		// drain current light source
		if (!this.isKilling && !this.player.isStanding) this.elapsedLight += elapsed;
		
		this.meter.value = 0; // default
		if (this.elapsedLight >= 0) // not during the delay period
		{
			// ready for a new light source, batteries available
			if (this.lightsource < this.lightsourceBattery && this.batteryCount)
			{
				this.elapsedLight	= 0;
				this.lightsource 	= this.lightsourceBattery;
				this.lightDuration	= this.batteryDuration;
				this.batteryCount--;
			}
			// current battery has drained
			else if (this.lightsource == this.lightsourceBattery && this.elapsedLight >= this.lightDuration)
			{
				this.lightsource 	= this.lightsourceNone;
				this.elapsedLight 	= -this.batteryDelay;
				
				if (this.batteryCount)
				{
					this.queueDialog(localize('Time for a new battery.'));
				}
				else
				{
					this.queueDialog(localize('No more batteries.'));
				};
			}
			// ready for a new light source, matches available
			else if (this.lightsource < this.lightsourceMatch && this.matchCount)
			{
				this.elapsedLight	= 0;
				this.lightsource 	= this.lightsourceMatch;
				this.lightDuration	= this.matchDuration;
				this.matchCount--;
			}
			// current match has burnt out
			else if (this.lightsource == this.lightsourceMatch && this.elapsedLight >= this.lightDuration)
			{
				this.lightsource 	= this.lightsourceNone;
				this.elapsedLight	= -this.matchDelay;
				
				if (this.matchCount)
				{
					this.queueDialog(localize('Hot! Hot! Hot!'));
				}
				else
				{
					this.queueDialog(localize('Out of matches...'));
				};
			}
			else if (this.elapsedLight >= this.lightDuration)
			{
				this.lightsource = this.lightsourceEyes;
			};
			
			if (this.lightsource > this.lightsourceEyes)
			{
				this.meter.updateValue(1 - this.elapsedLight/this.lightDuration);
			};
		};
		
		// move player
		var o = this.player.body.origin;
		var n = Point(o.x + this.player.vx*elapsed*(this.player.isInWater?0.6:1.0), o.y + this.player.vy*elapsed*(this.player.isInWater?0.6:1.0));
		
		// collide against 4 adjacent/overlapped tiles
		var ts = 16;
		var sx = Math.floor(n.x/ts); // left tile
		var sy = Math.floor(n.y/ts); // top tile
		var nr = clone(this.player.body);
		var dx = this.player.vx > 0 ? 1 : this.player.vx < 0 ? -1 : 0;
		var dy = this.player.vy > 0 ? 1 : this.player.vy < 0 ? -1 : 0;
		var c = this.player.center();
		c.y += 4; // set lower since Tomo is half-head
		this.player.isInWater = NO;
		
		var totalCollisions = 0;
		var softness = 7.9; // must be less than half tile size
		var softx = 0;
		var softy = 0;
		for (var y=0; y<2; y++)
		{
			for (var x=0; x<2; x++)
			{
				var nx = sx+x;
				var ny = sy+y;
				if (this.data.grid[ny] && this.data.grid[ny][nx]) // solid
				{
					nr.origin = n;
					var tr = Rect(nx*ts, ny*ts, ts, ts);
					
					if (rectIntersectsRect(this.player.body, tr))
					{
						totalCollisions++;
					};
					
					var xr = intersectingRect(nr, tr);
					if (!rectIsEmpty(xr)) // overlapping
					{
						if (dx) // moving left or right
						{
							var vy = Math.abs(this.player.vx);
							n.x -= dx * xr.size.width;
							if (xr.size.height < softness) // soften corners
							{
								var d = (n.y <  tr.origin.y) ? 1 : -1;
								var s = xr.size.height > 1 ? 1 : xr.size.height;
								softy = d * s;
							};
						}
						else if (dy) // moving up or down
						{
							n.y -= dy * xr.size.height;
							if (xr.size.width < softness) // soften corners
							{
								var d = (n.x <  tr.origin.x) ? 1 : -1;
								var s = xr.size.width > 1 ? 1 : xr.size.width;
								softx = d * s;
							};
						};
					};
				};
				
				if (this.data.water[ny] && this.data.water[ny][nx]) // water
				{
					var tr = Rect(nx*ts, ny*ts, ts, ts);
					if (rectContainsPoint(tr, c))
					{
						this.player.isInWater = YES;
					};
				};
			};
		};
		if (totalCollisions == 1)
		{
			n.x -= softx;
			n.y -= softy;
		};
		
		if (this.player.vy < 0) this.player.facing = 0;
		if (this.player.vx > 0) this.player.facing = 1;
		if (this.player.vy > 0) this.player.facing = 2;
		if (this.player.vx < 0) this.player.facing = 3;
		
		this.player.body.origin = n;
		this.meter.body.origin = Point(n.x,n.y-8);
		this.updateCamera();
		this.beam.center(this.player.center());
		
		if (!this.isKilling) // can't collect things when you're dead
		{
			// collide with random collectibles
			for (var i=0; i<this.collectibles.children.length; i++)
			{
				var collectible = this.collectibles.children[i];
				if (!collectible.isVisible) continue;

				if (rectContainsPoint(this.player.body, collectible.center()))
				{
					if (collectible instanceof Battery)
					{
						if (this.batteryCount < 6)
						{
							this.batteryCount++;
							collectible.isVisible = NO;

							this.queueDialog(localize('Found a *battery*!'));
							System.speaker.fx('audio/battery.ogg');
						}
						else
						{
							this.queueDialog(localize('Can\'t carry any more batteries.'));
						};
					}
					else if (collectible instanceof Matchbook)
					{
						if (this.matchCount < 32)
						{
							this.matchCount += 4;
							if (this.matchCount > 32) this.matchCount = 32;
							collectible.isVisible = NO;

							this.queueDialog(localize('Found a *matchbook*!'));
							System.speaker.fx('audio/matchbook.ogg');
						}
						else
						{
							this.queueDialog(localize('Can\'t carry any more matches.'));
						};
					}
					else if (collectible instanceof Talisman)
					{
						if (this.talismanCount < 4)
						{
							this.talismanCount++;
							collectible.isVisible = NO;

							this.queueDialog(localize('Found a *talisman*!'));
							this.queueDialog(localize('These things creep me out.'));
							System.speaker.fx('audio/talisman.ogg');
						}
						else
						{
							this.queueDialog(localize('Can\'t carry any more creepy talismen.'));
						};
					};
				};
			};
		}
		
		var shouldSwapZIndex = NO;
		// check for exit collisions, piggy back onto the swap zIndex checks
		if (rectContainsPoint(this.player.body, this.exit.center()))
		{
			this.clear();
			if (this.player.zIndex < this.exit.zIndex) shouldSwapZIndex = YES;
		};
		
		if (this.player.body.origin.y >= this.exit.body.origin.y)
		{
			if (this.player.zIndex < this.exit.zIndex) shouldSwapZIndex = YES;
		}
		else
		{
			if (this.player.zIndex > this.exit.zIndex) shouldSwapZIndex = YES;
		};
		
		if (shouldSwapZIndex)
		{
			var z = this.exit.zIndex;
			this.exit.zIndex = this.player.zIndex;
			this.player.zIndex = z;
			this.player.parent.children.sort(compareZIndex);
		};
		
		// update HUD counts
		this.talismanNum.number = this.talismanCount;
		this.batteryNum.number = this.batteryCount;
		this.matchNum.number = this.matchCount;
		
		if (this.elapsedLight < 0)
		{
			this.beam.currentTile = 9; // unadjusted eyes
		}
		else
		{
			if (this.lightsource == this.lightsourceBattery)
			{
				this.beam.currentTile = this.player.facing;
			}
			else if (this.lightsource == this.lightsourceMatch)
			{
				this.beam.currentTile = this.player.facing + 4;
			}
			else
			{
				if (this.beam.currentTile != 8)
				{
					this.queueDialog(localize('Eyes finally adjusted to the dark.'));
				};
				this.beam.currentTile = 8; // adjusted eyes
			}
		}
		
		if (this.player.isStanding) this.beam.currentTile = 8;
		
		// wtf is this?
		if (this.isEnding || this.player.isDead) this.beam.currentTile = 8; // override
		
		// and this?
		if (this.beam.currentTile >= 8) this.player.lightsource = 0; // none
		else if (this.beam.currentTile >=4) this.player.lightsource = 1; // matches
		else this.player.lightsource = 2; // flashlight
		
		// update miniplayer
		x1 = Math.floor(n.x/ts);
		y1 = Math.floor(n.y/ts);
		this.miniplayer.body.origin = Point(x1+this.minimap.body.origin.x-1, y1+this.minimap.body.origin.y-1);
		
		// check for compass collisions
		if (this.compass.isVisible)
		{
			if (rectContainsPoint(this.player.body, this.compass.center()))
			{
				this.hasFoundExit = YES;
				
				this.queueDialog(localize('Found a *compass*!'));
				System.speaker.fx('audio/compass.ogg');
			};
		}
		
		if (!this.hasFoundExit)
		{
			var fov = Rect(	this.player.body.origin.x-this.player.body.size.width,
							this.player.body.origin.y-this.player.body.size.height,
							this.player.body.size.width*3,
							this.player.body.size.height*3);
			if (rectIntersectsRect(fov, this.exit.body))
			{
				this.hasFoundExit = YES;
			};
		};
		
		if (this.hasFoundExit && !this.miniexit.isVisible)
		{
			this.compass.isVisible = NO;
			this.miniexit.isVisible = YES;
		};
		
		// + for no lightsource
		// []| for matches
		// []|| for flash light
		
		// update minimap reveal
		if (y1-1 >= 0) // row above
		{
			if (this.player.lightsource && x1-1 >= 0) this.minimap.reveal[y1-1][x1-1] = 1; // top left
			this.minimap.reveal[y1-1][x1] = 1; // top
			if (this.player.lightsource && x1+1 < this.minimap.reveal[y1-1].length) this.minimap.reveal[y1-1][x1+1] = 1; // top right
		};
		
		// this row
		if (x1-1 >= 0) this.minimap.reveal[y1][x1-1] = 1;
		this.minimap.reveal[y1][x1] = 1;
		if (x1+1 < this.minimap.reveal[y1].length) this.minimap.reveal[y1][x1+1] = 1;
		
		// row below
		if (y1+1 < this.minimap.reveal.length) // row above
		{
			if (this.player.lightsource && x1-1 >= 0) this.minimap.reveal[y1+1][x1-1] = 1; // bottom left
			this.minimap.reveal[y1+1][x1] = 1;
			if (this.player.lightsource && x1+1 < this.minimap.reveal[y1+1].length) this.minimap.reveal[y1+1][x1+1] = 1; // bottom right
		};
		
		if (this.player.lightsource)
		{
			// add extra row or column in front of player
			switch (this.player.facing)
			{
				case 0: // up
					if (y1-2 >= 0)
					{
						if (x1-1 >= 0) this.minimap.reveal[y1-2][x1-1] = 1; // top left
						this.minimap.reveal[y1-2][x1] = 1; // top
						if (x1+1 < this.minimap.reveal[y1-2].length) this.minimap.reveal[y1-2][x1+1] = 1; // top right
					};
					break;
				case 1: // right
					if (x1+2 >= 0)
					{
						if (y1-1 >= 0) this.minimap.reveal[y1-1][x1+2] = 1; // top right
						this.minimap.reveal[y1][x1+2] = 1; // right
						if (y1+1 < this.minimap.reveal.length) this.minimap.reveal[y1+1][x1+2] = 1; // bottom right
					};
					break;
				case 2: // down
					if (y1+2 < this.minimap.reveal.length)
					{
						if (x1-1 >= 0) this.minimap.reveal[y1+2][x1-1] = 1; // bottom left
						this.minimap.reveal[y1+2][x1] = 1;
						if (x1+1 < this.minimap.reveal[y1+2].length) this.minimap.reveal[y1+2][x1+1] = 1; // bottom right
					};
					break;
				case 3: // left
					if (x1-2 >= 0)
					{
						if (y1-1 >= 0) this.minimap.reveal[y1-1][x1-2] = 1; // top left
						this.minimap.reveal[y1][x1-2] = 1; // left
						if (y1+1 < this.minimap.reveal.length) this.minimap.reveal[y1+1][x1-2] = 1; // bottom left
					};
					break;
			};
			
			if (this.player.lightsource == 2)
			{
				// add another extra row or column in front of player
				
				switch (this.player.facing)
				{
					case 0: // up
						if (y1-3 >= 0)
						{
							if (x1-1 >= 0) this.minimap.reveal[y1-3][x1-1] = 1; // top left
							this.minimap.reveal[y1-3][x1] = 1; // top
							if (x1+1 < this.minimap.reveal[y1-3].length) this.minimap.reveal[y1-3][x1+1] = 1; // top right
						};
						break;
					case 1: // right
						if (x1+3 >= 0)
						{
							if (y1-1 >= 0) this.minimap.reveal[y1-1][x1+3] = 1; // top right
							this.minimap.reveal[y1][x1+3] = 1; // right
							if (y1+1 < this.minimap.reveal.length) this.minimap.reveal[y1+1][x1+3] = 1; // bottom right
						};
						break;
					case 2: // down
						if (y1+3 < this.minimap.reveal.length)
						{
							if (x1-1 >= 0) this.minimap.reveal[y1+3][x1-1] = 1; // bottom left
							this.minimap.reveal[y1+3][x1] = 1;
							if (x1+1 < this.minimap.reveal[y1+3].length) this.minimap.reveal[y1+3][x1+1] = 1; // bottom right
						};
						break;
					case 3: // left
						if (x1-3 >= 0)
						{
							if (y1-1 >= 0) this.minimap.reveal[y1-1][x1-3] = 1; // top left
							this.minimap.reveal[y1][x1-3] = 1; // left
							if (y1+1 < this.minimap.reveal.length) this.minimap.reveal[y1+1][x1-3] = 1; // bottom left
						};
						break;
				};
			};
		};
	},
	togglePause : function()
	{
		this.isPaused = !this.isPaused;
		this.paused.isVisible = this.isPaused;
		this.hud.isVisible = !this.isPaused;
		this.pausedElapsed = 0;
		
		// if (this.isPaused) System.speaker.pause();
		// else System.speaker.resume();
	},
	handleEvent : function(ie)
	{
		if (this.isEnding) return;
		if (this.player.isDead) return;
		
		var speed = 48;
		switch(ie.type)
		{
			case 'keydown':
				this.player.move();
				switch(ie.key)
				{
					case InputManager.KEY.UP:
						this.player.vx = 0;
						this.player.vy = -speed;
						this.joystick.y = -1;
						break;
					case InputManager.KEY.RIGHT:
						this.player.vx = speed;
						this.player.vy = 0;
						this.joystick.x = 1;
						break;
					case InputManager.KEY.DOWN:
						this.player.vx = 0;
						this.player.vy = speed;
						this.joystick.y = 1;
						break;
					case InputManager.KEY.LEFT:
						this.player.vx = -speed;
						this.player.vy = 0;
						this.joystick.x = -1;
						break;
				}
				break;
			case 'keyup':
				switch(ie.key)
				{
					case InputManager.KEY.UP:
						this.player.vy = 0;
						if (this.joystick.y==-1) this.joystick.y = 0;
						break;
					case InputManager.KEY.RIGHT:
						this.player.vx = 0;
						if (this.joystick.x==1) this.joystick.x = 0;
						break;
					case InputManager.KEY.DOWN:
						this.player.vy = 0;
						if (this.joystick.y==1) this.joystick.y = 0;
						break;
					case InputManager.KEY.LEFT:
						this.player.vx = 0;
						if (this.joystick.x==-1) this.joystick.x = 0;
						break;
					case InputManager.KEY.ACTION:
						this.togglePause();
						break;
				}
				
				// resume previous direction
				if (this.player.vx == 0)
				{
					this.player.vy = speed * this.joystick.y;
				}
				if (this.player.vy == 0)
				{
					this.player.vx = speed * this.joystick.x;
				};
				break;
			
			// touch doesn't use this.joystick
			case 'began':
				this.player.move();
				
				this.restPoint = System.input.lastTouch;
				if (!this.isPaused)
				{
					this.touch.currentTile = 0;
					this.touch.center(this.restPoint);
					this.touch.isVisible = YES;
				};
				break;
			case 'moved':
				
				var diff = Point(System.input.lastTouch.x - this.restPoint.x, System.input.lastTouch.y - this.restPoint.y);
				var dist = diff.x*diff.x + diff.y*diff.y;
				var sensitivity = 2;
				var adiff = Point(Math.abs(diff.x), Math.abs(diff.y));
				
				// http://stackoverflow.com/a/3309658/145965
				var theta = Math.atan2(-diff.y, diff.x);
				if (theta < 0) theta += 2 * Math.PI;
				var angle = theta * 180 / Math.PI;
				
				
				if (dist >= sensitivity)
				{
					if (angle <= 45 || angle > 315) // right
					{
						this.player.vx = speed;
						this.player.vy = 0;
						this.touch.currentTile = 1;
					}
					else if (angle > 45 && angle <= 135) // up
					{
						this.player.vx = 0;
						this.player.vy = -speed;
						this.touch.currentTile = 2;
					}
					else if (angle > 135 && angle <= 225) // left
					{
						this.player.vx = -speed;
						this.player.vy = 0;
						this.touch.currentTile = 3;
					}
					else // down
					{
						this.player.vx = 0;
						this.player.vy = speed;
						this.touch.currentTile = 4;
					};
				};
				break;
			case 'ended':
				this.player.vx = 0;
				this.player.vy = 0;
				this.touch.isVisible = NO;
				
				if (rectContainsPoint(this.pauseRect,System.input.lastTouch) || this.isPaused)
				{
					this.togglePause();
				};
				break;
		};
	}
});

var TitleState = State.extend(
{
	init : function()
	{
		this._super();
		this.addChild(new Tile(0,0,240,160,'images/sinkhole.png'));
		
		this.sentry = new SentrySans;
		this.sentry.delay = 0;
		this.addChild(this.sentry);
		this.sentry.alignment = TextMap.alignmentTypes.centered;
		this.sentry.setText(localize('Press *Any Arrow Key* to Start'));
		this.sentry.maxWidth = 240;
		this.sentry.body.origin.y = 132;
		
		this.flashElapsed = 0;
		
		System.speaker.loop('audio/loop.ogg');
		
		System.input.registerTarget(this);
	},
	update : function(elapsed)
	{
		this.flashElapsed += elapsed;
		
		var dur = 0.4;
		if (this.flashElapsed >= dur)
		{
			this.sentry.isVisible = !this.sentry.isVisible;
			this.flashElapsed -= dur;
		}
	},
	handleEvent : function(ie)
	{
		var wasHandled = NO;
		switch(ie.type)
		{
			case 'ended':
				wasHandled = YES;
				break;
			case 'keyup':
				switch(ie.key)
				{
					case InputManager.KEY.UP:
					case InputManager.KEY.RIGHT:
					case InputManager.KEY.DOWN:
					case InputManager.KEY.LEFT:
					case InputManager.KEY.ACTION:
						wasHandled = YES;
						break;
				}
				break;
		};
		if (wasHandled) System.loadState(new PrologueState);
	},
});

var PrologueState = State.extend(
{
	init : function()
	{
		this._super();
		
		// dialog
		this.sentry = new SentrySans;
		this.sentry.body.origin = Point(32, 75);
		this.addChild(this.sentry); 
		
		this.dialogs = [];
		this.dialogElapsed = 0;
				
		this.queueDialog(localize('Tomo was on a routine survey mission'));
		this.queueDialog(localize('when the earth opened up'));
		this.queueDialog(localize('and swallowed him whole.'));
		
		this.queueDialog(localize('Guide Tomo out of the sinkhole'));
		this.queueDialog(localize('before he runs out of batteries'));
		this.queueDialog(localize('or burns through all his matches.'));
		
		this.queueDialog(localize('It will be a grueling, lonely ascent. '));
		this.queueDialog(localize('At least, Tomo thinks he\'s alone...'));
		this.queueDialog(localize('He *hopes* he\'s alone.'));
		
		this.displayNextDialog();
		
		System.input.registerTarget(this);
		System.speaker.fx('audio/start.ogg');
	},
	queueDialog : function(str)
	{
		if (contains(this.dialogs, str)) return;
		if (!this.dialogs.length) this.dialogElapsed = 10;
		this.dialogs.push(str);
	},
	displayNextDialog : function()
	{
		if (this.dialogs.length)
		{
			this.sentry.setText(this.dialogs.shift());
			this.dialogElapsed = 0;
		}
		else {
			System.loadState(new PlayState);
		};
	},
	update : function(elapsed)
	{
		this.dialogElapsed += elapsed;
		if (this.dialogElapsed >= 4)
		{
			this.displayNextDialog();
		};
		this._super(elapsed);
	},
	handleEvent : function(ie)
	{
		var wasHandled 	= NO;
		var skipAll		= NO;
		switch(ie.type)
		{
			case 'ended':
				wasHandled = YES;
				break;
			case 'keyup':
				switch(ie.key)
				{
					case InputManager.KEY.ACTION:
						skipAll = YES;
					case InputManager.KEY.UP:
					case InputManager.KEY.RIGHT:
					case InputManager.KEY.DOWN:
					case InputManager.KEY.LEFT:
						wasHandled = YES;
						break;
				}
				break;
		};
		if (wasHandled)
		{
			if (skipAll)
			{
				System.loadState(new PlayState);
			}
			else if (!this.sentry.hasFinished)
			{
				this.sentry.advance();
			}
			else
			{
				this.displayNextDialog();
			};
		};
	},
});

var DebugState = State.extend(
{
	init : function()
	{
		this._super();
		this.addChild(new Rectangle(0,0,240,160,'red'));
		
		this.mask = new Mask;
		this.mask.zIndex = 3;
		this.addChild(this.mask);

		this.beam = new Tile(0,0,132,132,'images/beam-mask.png');
		this.mask.addChild(this.beam);
	},
});

var strings = {};
function localize(str)
{
	var lang = location.hash.replace('#', '') || window.navigator.userLanguage || window.navigator.language;
	if (lang.match(/(ja|jp)/) && strings['ja'][str]) {
		str = strings['ja'][str];
	};
	return str;
};
// Thanks @ourmaninjapan!
strings['ja'] = {
	'Sinkhole' : '',
	'Press *Any Arrow Key* to Start' : '',
	'Paused' : '',
	'Game Over' : '',
	
	'Tomo was on a routine survey mission' : '',
	'when the earth opened up' : '',
	'and swallowed him whole.' : '',
	'Guide Tomo out of the sinkhole' : '',
	'before he runs out of batteries' : '',
	'or burns through all his matches.' : '',
	'It will be a grueling, lonely ascent. ' : '',
	'At least, Tomo thinks he\'s alone...' : '',
	'He *hopes* he\'s alone.' : '',
	
	'How did I survive that fall?' : '',
	'I need to find a way out of here.' : '',
	'My arm is definitely broken and' : '',
	'these batteries won\'t last forever...' : '',
	
	'I wonder how far down I am...' : '',
	'This is starting to look familiar.' : '',
	
	'Up I go...' : '',
	
	'Ugh!' : '',
	
	'What was that!' : '',
	'I must be hearing things...' : '',
	
	'Found a *battery*!' : '** ',
	'Can\'t carry any more batteries.' : '',
	'Found a *matchbook*!' : '**',
	'Can\'t carry any more matches.' : '',
	'Found a *talisman*!' : '**',
	'These things creep me out.' : '',
	'Can\'t carry any more creepy talismen.' : '',
	'Found a *compass*!' : '**',
	'Time for a new battery.' : '',
	'No more batteries.' : '',
	'Hot! Hot! Hot!' : '', // fingers burnt by match burning down
	'Out of matches...' : '',
	'Eyes finally adjusted to the dark.' : ''
};


// BOOT ---------------------------------------------------------------
var System = new GameSystem('game', 240, 160);
if (navigator.userAgent.match(/webkit/i))
{
	System.autoscale(); // Safari (non-nightly) needs and can handle it.
}
else
{
	System.autozoom(); // Firefox doesn't and couldn't if it needed to.
};
Textures.preload([
	'images/alert.png',
	'images/battery.png',
	'images/beam-mask.png',
	'images/campfire.png',
	'images/compass.png',
	'images/hud-nums.png',
	'images/hud.png',
	'images/matchbook.png',
	'images/minimap-border.png',
	'images/miniplayer.png',
	'images/minivine.png',
	'images/paused.png',
	'images/sentry-sans+katakana.png',
	'images/sinkhole.png',
	'images/slash.png',
	'images/start.png',
	'images/talisman.png',
	'images/tiles-water.png',
	'images/tiles.png',
	'images/tomo.png',
	'images/touch.png',
	'images/vine-hole.png',
	'images/vine.png'
]);
System.speaker.preload(
[
	'audio/loop.ogg',
	'audio/battery.ogg',
	'audio/compass.ogg',
	'audio/flee.ogg',
	'audio/matchbook.ogg',
	'audio/slash.ogg',
	'audio/stalker.ogg',
	'audio/start.ogg',
	'audio/talisman.ogg'
]);
System.loadState(new TitleState);

</script>

</body></html>
